<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>SWIFT RECORDS</title>
  <meta name="viewport" content="width=device-width, initial-scale=0.75">
  <meta name="mobile-web-app-capable" content="yes">
  <style>
  /* Reset & Base */
  body {
    margin: 0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    display: flex;
    min-height: 100vh;
    background: linear-gradient(135deg, #f0f4ff, #d9e2ff);
    color: #333;
  }

  /* Header */
  header {
    position: fixed;
    top: 0; left: 0; right: 0;
    height: 60px;
    background: linear-gradient(90deg, #0052cc, #003d99);
    color: #f0f5ff;
    display: flex;
    align-items: center;
    padding: 0 24px;
    justify-content: space-between;
    box-shadow: 0 2px 8px rgba(0, 45, 102, 0.6);
    z-index: 10;
  }

  header h2 {
    margin: 0;
    font-size: 22px;
    font-weight: 700;
    letter-spacing: 1px;
    flex-shrink: 0; /* Prevent shrinking */
  }

  .info {
    display: flex; /* Make info a flex container */
    align-items: center;
    flex-shrink: 0; /* Prevent info block from shrinking */
  }

  .info span {
    margin-left: 20px;
    color: #ffde59;
    font-size: 14px;
    font-weight: 600;
    text-shadow: 0 0 3px rgba(255, 222, 89, 0.7);
    white-space: nowrap; /* Prevent text wrapping */
    overflow: hidden; /* Hide overflow content */
    text-overflow: ellipsis; /* Show ellipsis for overflow */
  }

  /* Menu toggle (mobile) */
  .menu-toggle {
    display: none;
    cursor: pointer;
    font-size: 28px;
    margin-right: 12px;
    color: gold;
    user-select: none;
  }

  /* Navigation menu */
  nav.menu {
    position: fixed;
    top: 60px; left: 0; bottom: 0;
    width: 220px;
    background: #ffffff;
    box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
    padding: 15px 12px;
    display: flex;
    flex-direction: column;
    gap: 12px;
    overflow-y: auto;
    transition: background 0.3s ease;
    border-right: 2px solid #004d99;
  }

  nav.menu button {
    padding: 12px 15px;
    background: linear-gradient(135deg, #e6f0ff, #cce0ff);
    border: 1px solid #99b3ff;
    border-radius: 8px;
    text-align: left;
    cursor: pointer;
    font-weight: 600;
    color: #003d99;
    box-shadow: inset 0 0 5px rgba(0, 61, 153, 0.2);
    transition:
      background 0.3s ease,
      color 0.3s ease,
      box-shadow 0.3s ease;
    user-select: none;
  }

  nav.menu button:hover,
  nav.menu button.active {
    background: linear-gradient(135deg, #0052cc, #003d99);
    color: #fff;
    box-shadow: 0 4px 10px rgba(0, 82, 204, 0.6);
    border-color: #002966;
  }

  /* Screens / content */
  .screen {
    display: none;
    padding: 24px 30px;
    margin-left: 240px;
    margin-top: 60px;
    width: calc(100% - 240px);
    background: #fff;
    border-radius: 12px 0 0 12px;
    box-shadow: 0 2px 12px rgba(0, 0, 0, 0.07);
    min-height: calc(100vh - 80px);
  }

  .visible {
    display: block;
  }

  /* Form controls */
  input, select, button, textarea {
    display: block;
    margin: 12px 0;
    padding: 10px 14px;
    width: 100%;
    max-width: 420px;
    box-sizing: border-box;
    font-size: 16px;
    font-weight: 500;
    border: 1.5px solid #c1c9ff;
    border-radius: 8px;
    background: #f9fbff;
    transition: border-color 0.3s ease, box-shadow 0.3s ease;
    outline-offset: 2px;
  }
  label {
    font-weight: 600;
    color: #003d99;
    font-size: 14px;
    margin-top: 10px;
    display: block;
  }


  input:focus, select:focus, textarea:focus {
    border-color: #0052cc;
    box-shadow: 0 0 8px rgba(0, 82, 204, 0.4);
    background: #fff;
  }

  button {
    background: linear-gradient(135deg, #004d99, #0066ff);
    color: #fff;
    border: none;
    cursor: pointer;
    font-weight: 700;
    box-shadow: 0 3px 8px rgba(0, 102, 255, 0.6);
    user-select: none;
    max-width: 200px;
    transition: background 0.3s ease, box-shadow 0.3s ease;
  }

  button:hover {
    background: linear-gradient(135deg, #003366, #0052cc);
    box-shadow: 0 5px 14px rgba(0, 102, 255, 0.8);
  }

  /* Tables */
  table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 16px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
    border-radius: 10px;
    overflow: hidden;
  }

  th, td {
    border-bottom: 1px solid #e1e7ff;
    padding: 12px 18px;
    text-align: left;
    color: #222f55;
  }

  th {
    background: linear-gradient(90deg, #0073e6, #0052cc);
    color: white;
    font-weight: 700;
    letter-spacing: 0.05em;
  }

  tr:hover {
    background: #f0f5ff;
  }

  /* Delete button */
  .delete-btn {
    color: #d93025;
    margin-left: 14px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    user-select: none;
    transition: color 0.3s ease;
  }

  .delete-btn:hover {
    color: #a6211f;
  }
  #voucherInventorySection {
    border: 1px solid #cce0ff;
    padding: 15px;
    margin-top: 15px;
    border-radius: 8px;
    background-color: #f7f9ff;
  }
  #voucherInventorySection h4 {
    margin-top: 0;
    color: #003d99;
  }


  /* Responsive */
  @media (max-width: 768px) {
    header {
      padding: 0 12px; /* Reduce padding on mobile */
      flex-wrap: nowrap; /* Prevent header children from wrapping */
    }

    header h2 {
      font-size: 18px; /* Smaller font for main title */
    }

    .info {
      gap: 5px; /* Reduce gap between company and year */
    }

    .info span {
      margin-left: 10px; /* Reduce margin between spans */
      font-size: 12px; /* Smaller font for company/year info */
    }

    nav.menu {
      position: fixed;
      top: 60px;
      left: -240px;
      width: 220px;
      height: calc(100% - 60px);
      background: #f0f4ff;
      border-right: 2px solid #004d99;
      transition: left 0.3s ease;
      box-shadow: 2px 0 12px rgba(0, 45, 102, 0.2);
      z-index: 1000;
    }

    nav.menu.open {
      left: 0;
    }

    .screen {
      margin-left: 0;
      margin-top: 80px;
      width: 100%;
      border-radius: 0;
      box-shadow: none;
    }

    .menu-toggle {
      display: block;
      color: gold;
    }
  }
/* ===== Enhanced Dark Mode ===== */
body.dark {
  background: #121212;
  color: #e0e0e0;
}

/* Header & Navigation */
body.dark header {
  background: linear-gradient(90deg, #1a237e, #0d47a1);
  color: #fff;
}
body.dark nav.menu {
  background: #1f1f1f;
  border-right-color: #333;
}

/* Screens */
body.dark .screen {
  background: #1f1f1f;
  color: #e0e0e0;
  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.3);
}
body.dark label {
    color: #bb86fc;
}
body.dark #voucherInventorySection {
    border-color: #333;
    background-color: #2a2a2a;
}
body.dark #voucherInventorySection h4 {
    color: #bb86fc;
}


/* Forms */
body.dark input,
body.dark select,
body.dark textarea {
  background: #2d2d2d;
  border-color: #444;
  color: #f0f0f0;
}
body.dark input:focus,
body.dark select:focus,
body.dark textarea:focus {
  border-color: #bb86fc;
  box-shadow: 0 0 8px rgba(187, 134, 252, 0.4);
  background: #333;
}

/* Buttons */
body.dark button {
  background: linear-gradient(135deg, #3700b3, #6200ee);
  color: #fff;
  box-shadow: 0 3px 8px rgba(98, 0, 238, 0.6);
}
body.dark button:hover {
  background: linear-gradient(135deg, #6200ee, #3700b3);
  box-shadow: 0 5px 14px rgba(98, 0, 238, 0.8);
}
body.dark nav.menu button {
  background: linear-gradient(135deg, #333, #444);
  border-color: #555;
  color: #e0e0e0;
}
body.dark nav.menu button:hover {
  background: linear-gradient(135deg, #444, #555);
}
body.dark nav.menu button.active {
    background: linear-gradient(135deg, #3700b3, #6200ee);
    color: #fff;
}


/* Tables */
body.dark table {
  background: #1f1f1f;
  color: #e0e0e0;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
}
body.dark th {
  background: linear-gradient(90deg, #3700b3, #6200ee);
  color: white;
}
body.dark td {
  border-bottom-color: #333;
  color: #e0e0e0;
}
body.dark tr:hover {
  background: #333;
}

/* Special Elements */
body.dark .delete-btn {
  color: #ff6e6e;
}
body.dark .delete-btn:hover {
  color: #ff4444;
}

/* Dark mode toggle button */
body.dark #darkModeToggle { /* Corrected ID */
  background: linear-gradient(135deg, #6200ee, #3700b3);
}
body.dark #darkModeToggle:hover { /* Corrected ID */
  background: linear-gradient(135deg, #7c4dff, #651fff);
}


ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
}

ul li {
  display: flex; /* Make list items flex containers */
  justify-content: space-between;
  align-items: center;
  background: #f7f9ff;
  padding: 10px 14px;
  margin-bottom: 8px;
  border-radius: 8px;
  box-shadow: 0 1px 4px rgba(0, 45, 102, 0.1);
  font-weight: 500;
  color: #2a2f45;
  transition: background 0.3s ease;
  flex-wrap: nowrap; /* Prevent wrapping for the main li content */
}
body.dark ul li {
    background: #2d2d2d;
    color: #e0e0e0;
    box-shadow: 0 1px 4px rgba(0,0,0,0.3);
}
body.dark ul li:hover {
    background: #383838;
}


ul li:hover {
  background: #e6f0ff;
}

/* Ensure action buttons are always on one line */
.action-buttons {
  display: flex;
  align-items: center;
  gap: 8px; /* Space between delete and select buttons */
  flex-shrink: 0; /* Prevent buttons from shrinking */
  margin-left: 15px; /* Add some space between text and buttons */
}

ul li span.delete-btn,
ul li span.edit-btn { /* Style for edit button icon */
  font-size: 14px;
  font-weight: bold;
  color: #d93025; /* Red for delete */
  cursor: pointer;
  user-select: none;
  transition: color 0.3s ease;
}

ul li span.edit-btn {
    color: #0052cc; /* Blue for edit */
}
body.dark ul li span.edit-btn {
    color: #bb86fc; /* Purple for dark mode edit */
}


ul li button {
  font-size: 14px;
  padding: 6px 12px;
  background: #004d99;
  color: white;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  transition: background 0.3s ease;
  margin: 0; /* Remove default button margins */
}

ul li button:hover {
  background: #002b66;
}
body.dark ul li button {
    background: #3700b3;
}
body.dark ul li button:hover {
    background: #6200ee;
}


@media (max-width: 768px) {
  ul li {
    flex-direction: row; /* Keep items in a row */
    align-items: center; /* Center align items vertically */
    padding: 8px 12px; /* Slightly reduce padding */
  }

  ul li div.action-buttons {
    margin-top: 0; /* Remove top margin */
    display: flex;
    gap: 10px; /* Consistent gap between buttons */
    width: auto; /* Don't force full width */
    justify-content: flex-end; /* Align buttons to the end */
    flex-wrap: nowrap; /* Prevent wrapping */
    flex-shrink: 0; /* Prevent shrinking */
    min-width: fit-content;
    margin-left: 10px; /* Adjust margin for mobile */
  }

  ul li span:first-child {
    flex: 1; /* Allow text to take available space */
    min-width: 0; /* Allow text to shrink if needed */
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  ul li button, 
  ul li .delete-btn,
  ul li .edit-btn { /* Apply to edit button too */
    font-size: 18px; /* Slightly smaller font for buttons */
    padding: 4px 8px; /* Smaller padding for buttons */
  }

  .delete-btn, .edit-btn { /* Remove left margin for icons */
    margin-left: 0; 
  }
  
 

/* Custom Confirmation Dialog Styles */
.confirmation-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.6);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 10000;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.confirmation-dialog {
    background: #fff;
    padding: 30px;
    border-radius: 12px;
    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
    text-align: center;
    max-width: 400px;
    width: 90%;
    transform: translateY(-20px);
    transition: transform 0.3s ease;
    color: #333;
}
body.dark .confirmation-dialog {
    background: #2a2a2a;
    color: #e0e0e0;
}

.confirmation-dialog p {
    margin-bottom: 25px;
    font-size: 17px;
    font-weight: 500;
}

.confirmation-dialog .buttons {
    display: flex;
    justify-content: center;
    gap: 15px;
}

.confirmation-dialog button {
    padding: 10px 25px;
    border-radius: 8px;
    font-weight: 600;
    cursor: pointer;
    transition: background 0.2s ease, transform 0.1s ease;
    max-width: none; /* Override general button max-width */
    width: auto;
    display: inline-block; /* Ensure they lay out correctly */
    margin: 0; /* Remove default button margins */
}

.confirmation-dialog button.confirm-yes {
    background: linear-gradient(135deg, #dc3545, #c82333);
    color: white;
    box-shadow: 0 2px 5px rgba(220, 53, 69, 0.4);
}
.confirmation-dialog button.confirm-yes:hover {
    background: linear-gradient(135deg, #c82333, #bd2130);
    transform: translateY(-1px);
}
body.dark .confirmation-dialog button.confirm-yes {
    background: linear-gradient(135deg, #ff6e6e, #e65c5c);
}
body.dark .confirmation-dialog button.confirm-yes:hover {
    background: linear-gradient(135deg, #e65c5c, #cc4444);
}


.confirmation-dialog button.confirm-no {
    background: linear-gradient(135deg, #6c757d, #5a6268);
    color: white;
    box-shadow: 0 2px 5px rgba(108, 117, 125, 0.4);
}
.confirmation-dialog button.confirm-no:hover {
    background: linear-gradient(135deg, #5a6268, #4e555b);
    transform: translateY(-1px);
}
body.dark .confirmation-dialog button.confirm-no {
    background: linear-gradient(135deg, #444, #555);
}
body.dark .confirmation-dialog button.confirm-no:hover {
    background: linear-gradient(135deg, #555, #666);
}

/* Custom Input for Confirmation Dialog (for edit function) */
.confirmation-dialog input {
    width: calc(100% - 20px); /* Adjust width for padding */
    padding: 10px;
    margin: 15px auto; /* Center the input */
    border: 1px solid #ccc;
    border-radius: 5px;
    font-size: 16px;
    display: block; /* Ensure it takes its own line */
    box-sizing: border-box; /* Include padding in width */
}
body.dark .confirmation-dialog input {
    background: #333;
    color: #e0e0e0;
    border-color: #555;
}


</style>


</head>
<body>

<header>
  <div class="menu-toggle" onclick="toggleMenu()">☰</div>
  <h2>SWIFT RECORDS</h2>
  <div class="info">
    <span id="currentCompany"></span>
    <span id="currentYear"></span>
  </div>
</header>

<nav id="sideMenu" class="menu">
  <button id="navCompany" onclick="showScreen('companyScreen')">Company</button>
  <button id="navYear" onclick="showScreen('yearScreen')">Year</button>
  <button id="navGroup" onclick="showScreen('groupScreen')">Groups</button>
  <button id="navLedger" onclick="showScreen('ledgerScreen')">Ledgers</button>
  <button id="navVoucher" onclick="showScreen('voucherScreen')">Vouchers</button>
  <button id="navStockMaster" onclick="showScreen('stockMasterScreen')">Stock Master</button>
  <button id="navInventory" onclick="showScreen('inventoryScreen')">Stock Adjustments</button> <button id="navDaybook" onclick="showScreen('daybookScreen'); renderDaybook();">Daybook</button>
  <button id="navReports" onclick="showScreen('reportsScreen'); showReports();">Reports</button>
  <button id="navSettings" onclick="showScreen('settingsScreen')">Settings</button>
</nav>

<section id="companyScreen" class="screen">
  <h3>Company</h3>
  <input id="companyName" placeholder="Company Name">
  <button onclick="createCompany()">Create</button>
  <ul id="companyList"></ul>
</section>

<section id="yearScreen" class="screen">
  <h3>Financial Year</h3>
  <input id="yearInput" placeholder="e.g., 2024-25">
  <button onclick="addYear()">Add Year</button>
  <ul id="yearList"></ul>
</section>

<section id="groupScreen" class="screen">
  <h3>Groups</h3>
  <input id="groupName" placeholder="Group Name">
  <button onclick="addGroup()">Add</button>
  <ul id="groupList"></ul>
</section>

<section id="ledgerScreen" class="screen">
  <h3>Ledgers</h3>
  <input id="ledgerName" placeholder="Ledger Name">
  <label for="ledgerGroup">Group:</label>
  <select id="ledgerGroup"></select>
  <label for="openingBalance">Opening Balance (Optional):</label>
  <input id="openingBalance" type="number" placeholder="Enter opening balance">
  <button onclick="addLedger()">Add</button>
  <ul id="ledgerList"></ul>
</section>

<section id="voucherScreen" class="screen">
  <h3>Vouchers</h3>
  <label for="debit">Debit Ledger:</label>
  <select id="debit"></select>
  <label for="credit">Credit Ledger:</label>
  <select id="credit"></select>
  <label for="amount">Amount (₹):</label>
  <input id="amount" placeholder="Amount" type="number">
  <label for="voucherDate">Date:</label>
  <input id="voucherDate" type="date">
  <label for="voucherType">Voucher Type:</label>
  <select id="voucherType">
    <option>Purchase</option>
    <option>Sales</option>
    <option>Payment</option>
    <option>Receipt</moption>
    <option>Journal</option>
    <option>Contra</option>
  </select>
  <label for="narration">Narration:</label>
  <textarea id="narration" placeholder="Narration (max 200 chars)"></textarea>

  <div id="voucherInventorySection" style="display:none;">
    <h4>Inventory Details</h4>
    <label for="voucherStockItem">Stock Item:</label>
    <select id="voucherStockItem"></select>
    <label for="voucherStockQuantity">Quantity:</label>
    <input type="number" id="voucherStockQuantity" placeholder="Quantity of item">
    <label for="voucherPricePerUnit" id="labelVoucherPricePerUnit" style="display:none;">Price per Unit (₹):</label>
    <input type="number" id="voucherPricePerUnit" placeholder="Price per unit" style="display:none;">
    </div>

  <button id="addVoucherBtn" onclick="addVoucher()">Add Voucher</button>
  <h4>Voucher List</h4>
  <ul id="voucherList"></ul>
</section>

<section id="stockMasterScreen" class="screen">
  <h3>Stock Master</h3>

  <h4>Stock Groups</h4>
  <input id="stockGroupName" placeholder="Enter stock group">
  <button onclick="addStockGroup()">Add Group</button>
  <ul id="stockGroupList"></ul>

  <h4>Stock Categories</h4>
  <input id="stockCategoryName" placeholder="Enter stock category">
  <button onclick="addStockCategory()">Add Category</button>
  <ul id="stockCategoryList"></ul>

  <h4>Stock Keeping Units (SKUs)</h4>
  <input id="skuName" placeholder="Enter SKU name (e.g., Main Store)">
  <button onclick="addSKU()">Add SKU</button>
  <ul id="skuList"></ul>

  <h4>Stock Items</h4>
  <input id="stockItemName" placeholder="Item Name">
  <label for="stockGroupSelect">Group:</label>
  <select id="stockGroupSelect"></select>
  <label for="stockCategorySelect">Category:</label>
  <select id="stockCategorySelect"></select>
  <label for="stockSKUSelect">SKU/Location:</label>
  <select id="stockSKUSelect"></select>
  <input id="stockUnit" placeholder="Unit (e.g., pcs, kg, ltr)">
  <label for="stockOpeningQty">Opening Quantity:</label>
  <input id="stockOpeningQty" type="number" placeholder="Opening Quantity">
  <label for="stockOpeningRate">Opening Rate (per unit) (₹):</label>
  <input id="stockOpeningRate" type="number" placeholder="Opening Rate (per unit)">
  <label for="stockOpeningValue">Opening Value (Total ₹):</label>
  <input id="stockOpeningValue" type="number" placeholder="Total opening value" readonly>
  <button onclick="addStockItem()">Add Item</button>
  <ul id="stockItemList"></ul>
</section>


<section id="inventoryScreen" class="screen">
  <h3>Stock Adjustments</h3>
  <label for="adjustmentItemName">Stock Item:</label>
  <select id="adjustmentItemName"></select>
  <label for="adjustmentQuantity">Adjustment Quantity (+ for increase, - for decrease):</label>
  <input id="adjustmentQuantity" type="number" placeholder="e.g., 10 or -5">
  <label for="adjustmentReason">Reason for Adjustment:</label>
  <textarea id="adjustmentReason" placeholder="e.g., Opening stock correction, Damaged goods"></textarea>
  <button id="adjustStockBtn" onclick="performStockAdjustment()">Adjust Stock</button>
  
  <h4>Adjustment Log</h4>
  <ul id="stockAdjustmentLogList"></ul>
</section>


<section id="daybookScreen" class="screen">
  <h3>Daybook</h3>
  <table>
    <thead>
      <tr><th>Date</th><th>Type</th><th>Debit</th><th>Credit</th><th>Amount (₹)</th><th>Narration</th></tr>
    </thead>
    <tbody id="daybookTable"></tbody>
  </table>
</section>

<section id="reportsScreen" class="screen">
  <h3>Reports</h3>
  <div id="trialBalance"></div>
  <div id="pl"></div>
  <div id="balanceSheet"></div>
  <div id="inventoryReport"></div>
</section>

<section id="settingsScreen" class="screen">
    <h3>Settings</h3>
    <button id="darkModeToggle" onclick="document.body.classList.toggle('dark')">🌙 Toggle Dark Mode</button>
    <button id="refreshAppButton" onclick="refreshApp()">🔄 Refresh App</button>
    <button id="appGuideButton" onclick="showScreen('appGuideScreen')">📚 App Guide</button>
    <button id="clearDataButton" onclick="clearAllData()">⚠️ Clear All Data</button>
</section>

<section id="appGuideScreen" class="screen">
    <h3>📚 App Guide: SWIFT RECORDS</h3>
    <p>Welcome to SWIFT RECORDS, your personal accounting practice app! This guide will help you navigate the app and ensure accurate entries for correct report generation.</p>

    <h4>App Navigation</h4>
    <ul>
        <li>The <strong>side menu</strong> on the left allows you to switch between different modules of the app.</li>
        <li>Click on any button in the side menu (e.g., Company, Ledgers, Vouchers) to open its respective screen.</li>
        <li>On mobile, the <strong>☰ (Menu)</strong> icon in the header will toggle the side menu.</li>
    </ul>

    <h4>Important Modules & Tips</h4>

    <h5>1. Company & Financial Year</h5>
    <ul>
        <li><strong>Purpose:</strong> Start by creating a Company and then a Financial Year. All your accounting data is stored within a specific Company and Year.</li>
        <li><strong>Tip:</strong> Always ensure you have selected the correct Company and Financial Year from the respective screens before making any entries. The selected Company and Year are shown in the header.</li>
        <li><strong>Edit/Delete:</strong> Use the 'Select', '🪶 Edit', and '⛔ Delete' buttons to manage your companies and years. Editing renames, deleting permanently removes all associated data.</li>
    </ul>

    <h5>2. Groups & Ledgers</h5>
    <ul>
        <li><strong>Groups:</strong> These are categories for your ledgers (e.g., Current Assets, Capital Account, Sales Accounts). They help in organizing your accounts and generating financial reports.</li>
        <li><strong>Ledgers:</strong> These are individual accounts (e.g., Cash, Bank, Sales, Purchases, Rent Expense, Capital). Every transaction involves at least two ledgers.</li>
        <li><strong>Tip:</strong> Assign ledgers to the correct groups to ensure they appear under the right heads in your Profit & Loss Account and Balance Sheet. Default ledgers like 'Stock-in-Hand', 'Cost of Goods Sold', and 'Stock Adjustment Account' are automatically created.</li>
    </ul>

    <h5>3. Vouchers (Transactions)</h5>
    <ul>
        <li><strong>Purpose:</strong> This is where you record all your financial transactions.</li>
        <li><strong>Debit/Credit:</strong> Every transaction has a Debit and a Credit entry. Remember the golden rules of accounting:
            <ul>
                <li><strong>Personal Account:</strong> Debit the Receiver, Credit the Giver.</li>
                <li><strong>Real Account:</strong> Debit what comes in, Credit what goes out.</li>
                <li><strong>Nominal Account:</strong> Debit all expenses and losses, Credit all incomes and gains.</li>
            </ul>
        </li>
        <li><strong>Voucher Types:</strong>
            <ul>
                <li><strong>Purchase:</strong> For buying goods/services (Debit Purchase A/c or Asset, Credit Cash/Bank/Creditor). If it's a stock item purchase, 'Stock-in-Hand' will be debited.</li>
                <li><strong>Sales:</strong> For selling goods/services (Debit Cash/Bank/Debtor, Credit Sales A/c). If it's a stock item sale, 'Cost of Goods Sold' will also be debited and 'Stock-in-Hand' credited automatically.</li>
                <li><strong>Payment:</strong> For making payments (Debit Expense/Asset, Credit Cash/Bank).</li>
                <li><strong>Receipt:</strong> For receiving money (Debit Cash/Bank, Credit Income/Liability).</li>
                <li><strong>Journal:</strong> For non-cash transactions, adjustments, or transfers between ledgers (e.g., depreciation, outstanding expenses).</li>
                <li><strong>Contra:</strong> For cash deposits into bank or cash withdrawals from bank (involves only Cash and Bank ledgers).</li>
            </ul>
        </li>
        <li><strong>Narration:</strong> Always add a clear narration to explain the transaction.</li>
        <li><strong>Inventory Details:</strong> For 'Purchase' and 'Sales' vouchers, ensure you select the correct 'Stock Item' and 'Quantity'. This automatically updates your inventory.</li>
    </ul>

    <h5>4. Stock Master & Stock Adjustments</h5>
    <ul>
        <li><strong>Stock Master:</strong> Define your stock items, their groups, categories, units, and locations (SKUs). Set their opening quantities and rates.</li>
        <li><strong>Stock Adjustments:  Use this screen to manually increase or decrease stock quantities for reasons like damage, theft, or opening stock corrections. This will also create a journal entry to reflect the value change in your 'Stock-in-Hand' and 'Stock Adjustment Account' ledgers.</strong></li>
    </ul>

    <h5>5. Reports</h5>
    <ul>
        <li><strong>Daybook:</strong> A chronological record of all your vouchers for the selected financial year.</li>
        <li><strong>Trial Balance:</strong> Lists all ledger accounts with their final debit or credit balances. <strong>Key Tip: A correct Trial Balance should always have Total Debits equal to Total Credits.</strong> If it doesn't tally, there's an error in your voucher entries.</li>
        <li><strong>Profit & Loss Account:</strong> Shows your total income, total expenses, and calculates the net profit or loss for the financial year.</li>
        <li><strong>Balance Sheet:</strong> Presents your assets, liabilities, and capital at a specific point in time. <strong>Key Tip: A correct Balance Sheet should always tally (Assets = Liabilities + Capital).</strong> If it doesn't, revisit your entries.</li>
        <li><strong>Inventory Valuation Report:</strong> Provides a summary of your current stock items and their calculated values.</li>
    </ul>

    <h4>General Tips for Accuracy</h4>
    <ul>
        <li><strong>Double-Check:</strong> Always review your entries before saving.</li>
        <li><strong>Understand Concepts:</strong> Ensure you understand the accounting principles (debit/credit, types of accounts) behind each transaction.</li>
        <li><strong>Regularly Check Reports:</b> Use the Trial Balance and Balance Sheet frequently to catch errors early.</li>
        <li><strong>Use Narration:</strong> Clear narrations make it easier to understand and audit your entries later.</li>
    </ul>
    <p>Happy Accounting Practice!</p>
</section>

<script>
function toggleMenu() {
  document.getElementById('sideMenu').classList.toggle('open');
}

let data = { companies: {} };
let currentCompany = '';
let currentYear = '';
let currentVoucherId = null; // To store the ID of the voucher being edited
let currentAdjustmentId = null; // To store the ID of the adjustment being edited


function save() {
  localStorage.setItem('swiftData', JSON.stringify(data));
}
function load() {
  const d = localStorage.getItem('swiftData');
  if (d) data = JSON.parse(d);
  // Ensure essential structures exist after loading, especially for older data
   for (const compName in data.companies) {
        const company = data.companies[compName];
        for (const yearName in company.years) {
            const yearData = company.years[yearName];
            if (!yearData.stockItems) yearData.stockItems = [];
            if (!yearData.stockAdjustments) yearData.stockAdjustments = [];
            if (!yearData.vouchers) yearData.vouchers = []; // Ensure vouchers array exists

            // Initialize openingBalance for ledgers if not present
            if (yearData.ledgers) {
                yearData.ledgers.forEach(ledger => {
                    if (ledger.openingBalance === undefined) {
                        ledger.openingBalance = 0;
                    }
                });
            }
            // Ensure vouchers and adjustments have unique IDs after loading for old data
            yearData.vouchers.forEach(v => {
                if (!v.id) v.id = Date.now() + Math.random(); // Simple unique ID
                // Ensure inventoryDetails exists and has 'value' for old sales/purchase vouchers
                if ((v.type === 'Sales' || v.type === 'Purchase') && v.inventoryDetails && v.inventoryDetails.value === undefined) {
                    v.inventoryDetails.value = v.amount; // Assume voucher amount was the value
                }
            });
            yearData.stockAdjustments.forEach(adj => {
                if (!adj.id) adj.id = Date.now() + Math.random(); // Simple unique ID
            });
        }
    }
}

function setActiveNav(screenId) {
    document.querySelectorAll('nav.menu button').forEach(btn => btn.classList.remove('active'));
    const activeBtn = document.getElementById('nav' + screenId.replace('Screen', ''));
    if (activeBtn) {
        activeBtn.classList.add('active');
    }
}

function showScreen(id) {
   if (window.innerWidth <= 768) {
    document.getElementById('sideMenu').classList.remove('open');
  }

  document.querySelectorAll('.screen').forEach(s => s.classList.remove('visible'));
  document.getElementById(id).classList.add('visible');
  setActiveNav(id);

  if (id === 'companyScreen') renderCompanies();
  if (id === 'yearScreen') renderYears();
  if (id === 'groupScreen') renderGroups();
  if (id === 'ledgerScreen') renderLedgers();
  if (id === 'voucherScreen') {
      renderVouchers(); // Render existing vouchers
      populateLedgerDropdownsForVoucher(); // Populate debit/credit ledgers
      handleVoucherTypeChange(); // Initial setup for inventory section
      document.getElementById('voucherDate').valueAsDate = new Date(); // Set default date
      // Add event listeners for voucher amount calculation
      document.getElementById('voucherStockQuantity').removeEventListener('input', calculateVoucherAmount); // Remove existing to prevent duplicates
      document.getElementById('voucherPricePerUnit').removeEventListener('input', calculateVoucherAmount); // Remove existing
      document.getElementById('voucherStockItem').removeEventListener('change', calculateVoucherAmount); // Remove existing

      document.getElementById('voucherStockQuantity').addEventListener('input', calculateVoucherAmount);
      document.getElementById('voucherPricePerUnit').addEventListener('input', calculateVoucherAmount);
      document.getElementById('voucherStockItem').addEventListener('change', calculateVoucherAmount); // Also trigger on item change
      resetVoucherForm(); // Reset form when navigating to voucher screen
  }
  if (id === 'inventoryScreen') {
      populateAdjustmentItemDropdown();
      renderStockAdjustmentLog();
      resetAdjustmentForm(); // Reset form when navigating to inventory screen
  }
  if (id === 'stockMasterScreen') {
    renderStockGroups();
    renderStockCategories();
    renderSKUs();
    renderStockItems();
    // Add event listeners for stock item opening rate calculation
    document.getElementById('stockOpeningQty').removeEventListener('input', calculateStockOpeningRate); // Remove existing
    document.getElementById('stockOpeningRate').removeEventListener('input', calculateStockOpeningRate); // Remove existing

    document.getElementById('stockOpeningQty').addEventListener('input', calculateStockOpeningRate);
    document.getElementById('stockOpeningRate').addEventListener('input', calculateStockOpeningRate);
  }
}

document.getElementById('voucherType').addEventListener('change', handleVoucherTypeChange);

// Function to calculate voucher amount based on quantity and price per unit
function calculateVoucherAmount() {
    const voucherType = document.getElementById('voucherType').value;
    const stockQuantityInput = document.getElementById('voucherStockQuantity');
    const pricePerUnitInput = document.getElementById('voucherPricePerUnit');
    const amountInput = document.getElementById('amount');

    const quantity = parseFloat(stockQuantityInput.value);
    const pricePerUnit = parseFloat(pricePerUnitInput.value);

    // Only calculate if quantity and price per unit are valid numbers
    if (!isNaN(quantity) && quantity >= 0 && !isNaN(pricePerUnit) && pricePerUnit >= 0) {
        amountInput.value = (quantity * pricePerUnit).toFixed(2);
    } else {
        amountInput.value = ''; // Clear if inputs are invalid
    }
}


// Function to calculate stock item opening value based on quantity and rate
function calculateStockOpeningRate() {
    const openingQtyInput = document.getElementById('stockOpeningQty');
    const openingRateInput = document.getElementById('stockOpeningRate');
    const openingValueInput = document.getElementById('stockOpeningValue');

    const openingQty = parseFloat(openingQtyInput.value);
    const openingRate = parseFloat(openingRateInput.value);

    if (!isNaN(openingQty) && openingQty >= 0 && !isNaN(openingRate) && openingRate >= 0) {
        openingValueInput.value = (openingQty * openingRate).toFixed(2);
    } else {
        openingValueInput.value = ''; // Clear if inputs are invalid
    }
}


function handleVoucherTypeChange() {
    const type = document.getElementById('voucherType').value;
    const invSection = document.getElementById('voucherInventorySection');
    const pricePerUnitInput = document.getElementById('voucherPricePerUnit');
    const labelPricePerUnit = document.getElementById('labelVoucherPricePerUnit');
    const amountInput = document.getElementById('amount');

    if (type === 'Sales' || type === 'Purchase') {
        invSection.style.display = 'block';
        populateVoucherStockItemDropdown();
        
        pricePerUnitInput.style.display = 'block'; // Always show price per unit for Sales/Purchase
        labelPricePerUnit.style.display = 'block';
        amountInput.readOnly = true; // Amount is always calculated for Sales/Purchase

        // For Sales, the price per unit should be editable by the user
        if (type === 'Sales') {
            pricePerUnitInput.readOnly = false; // Allow manual entry for sales price
        } else { // Purchase
            pricePerUnitInput.readOnly = false; // Allow manual entry for purchase price
            pricePerUnitInput.value = ''; // Clear price per unit on type change to Purchase
        }
        calculateVoucherAmount(); // Recalculate amount when type changes
    } else {
        invSection.style.display = 'none';
        pricePerUnitInput.style.display = 'none';
        labelPricePerUnit.style.display = 'none';
        amountInput.readOnly = false; // Ensure amount is editable for non-inventory vouchers
        pricePerUnitInput.readOnly = false; // Reset read-only state
        pricePerUnitInput.value = ''; // Clear price per unit when inventory section is hidden
    }
}


function createCompany() {
  const name = document.getElementById('companyName').value.trim();
  if (!name) return notifyError("Company name is required.");
  if (data.companies[name]) return notifyError(`Company "${name}" already exists.`); // Check for existence
  if (!data.companies[name]) data.companies[name] = { years: {} };
  currentCompany = name;
  save(); renderCompanies(); updateHeader();
  notifySuccess("Company created successfully!");
  document.getElementById('companyName').value = '';
}

function selectCompany(name) {
  currentCompany = name;
  currentYear = ''; // Reset year when company changes
  renderCompanies(); updateHeader();
  // Potentially auto-select first year or show year screen
  if (Object.keys(data.companies[currentCompany].years).length > 0) {
    showScreen('yearScreen');
  } else {
    notifySuccess(`Company "${name}" selected. Please add or select a financial year.`);
  }
}

function editCompany(oldName) {
    showInputConfirmation(`Edit Company Name`, `Enter new name for "${oldName}":`, oldName, (newName) => {
        newName = newName.trim();
        if (!newName) {
            notifyError("New company name cannot be empty.");
            return;
        }
        if (newName === oldName) {
            notifyError("New name is the same as the old name.");
            return;
        }
        if (data.companies[newName]) {
            notifyError(`Company "${newName}" already exists.`);
            return;
        }

        // Perform the rename: copy data to new key, then delete old key
        data.companies[newName] = data.companies[oldName];
        delete data.companies[oldName];

        if (currentCompany === oldName) {
            currentCompany = newName;
        }
        save();
        renderCompanies();
        updateHeader();
        notifySuccess(`Company "${oldName}" renamed to "${newName}".`);
    });
}

function deleteCompany(name) {
  showConfirmation(`Are you sure you want to delete company "${name}" and all its data?`, () => {
    delete data.companies[name];
    if (currentCompany === name) {
        currentCompany = '';
        currentYear = '';
    }
    save(); renderCompanies(); updateHeader();
    notifySuccess(`Company "${name}" deleted.`);
  });
}

function renderCompanies() {
  const ul = document.getElementById('companyList');
  ul.innerHTML = '';
  for (let name in data.companies) {
    const li = document.createElement('li');
    const textSpan = document.createElement('span');
    textSpan.textContent = name + (name === currentCompany ? ' (Selected)' : '');
    li.appendChild(textSpan);
    
    const btnDiv = document.createElement('div');
    btnDiv.classList.add('action-buttons'); // Add class for styling
    
    // Select button
    const selBtn = document.createElement('button');
    selBtn.textContent = 'Select';
    selBtn.onclick = (e) => { e.stopPropagation(); selectCompany(name); };
    btnDiv.appendChild(selBtn); 

    // Edit button
    const editBtn = document.createElement('span');
    editBtn.textContent = '🪶';
    editBtn.className = 'edit-btn';
    editBtn.onclick = (e) => { e.stopPropagation(); editCompany(name); };
    btnDiv.appendChild(editBtn);

    // Delete button
    const delBtn = document.createElement('span');
    delBtn.textContent = '⛔';
    delBtn.className = 'delete-btn';
    delBtn.onclick = (e) => { e.stopPropagation(); deleteCompany(name); };
    btnDiv.appendChild(delBtn); 
    
    li.appendChild(btnDiv);
    ul.appendChild(li);
  }
}

function updateHeader() {
  document.getElementById('currentCompany').textContent = 'Company: ' + (currentCompany || 'None');
  document.getElementById('currentYear').textContent = 'Year: ' + (currentYear || 'None');
}

const defaultGroups = [
  'Capital Account', 'Loans (Liability)', 'Current Liabilities', 'Fixed Assets', 
  'Investments', 'Current Assets', 'Branch / Divisions', 'Sales Accounts', 
  'Purchase Accounts', 'Direct Incomes', 'Indirect Incomes', 
  'Indirect Expenses', 'Suspense Account', 'Stock-in-Hand', 
  'Sundry Debtors', 'Sundry Creditors', 'Bank Accounts', 'Cash-in-Hand',
  'Duties & Taxes', 'Provisions', 'Reserves & Surplus', 'Secured Loans', 'Unsecured Loans',
  'Bank OD A/c', 'Cost of Goods Sold', 'Stock Adjustment Account' // Added Stock Adjustment Account
];

function addYear() {
  if (!currentCompany) return notifyError("Select a company first.");
  const y = document.getElementById('yearInput').value.trim();
  if (!y.match(/^\d{4}-\d{2}$/)) return notifyError("Year format must beYYYY-YY (e.g., 2024-25).");
  const company = data.companies[currentCompany];
  if (company.years[y]) return notifyError(`Financial Year "${y}" already exists.`); // Check for existence

  if (!company.years[y]) {
    company.years[y] = { 
      groups: [...new Set([...defaultGroups])], // Ensure unique groups are added
      ledgers: [], 
      vouchers: [], 
      stockGroups: [], 
      stockCategories: [], 
      godowns: [], 
      stockItems: [],
      stockAdjustments: []
    };
    // Add essential default ledgers if they don't exist
    const yearLedgers = company.years[y].ledgers;
    const addDefaultLedger = (name, group) => {
        if (!yearLedgers.some(l => l.name === name)) {
            yearLedgers.push({ name: name, group: group, openingBalance: 0 });
        }
    };
    addDefaultLedger('Stock-in-Hand', 'Current Assets');
    addDefaultLedger('Cost of Goods Sold', 'Indirect Expenses');
    addDefaultLedger('Stock Adjustment Account', 'Indirect Expenses'); // Ensure this is also added
  }
  currentYear = y;
  save(); renderYears(); updateHeader();
  notifySuccess(`Financial Year "${y}" added and selected!`);
  document.getElementById('yearInput').value = '';
}

function selectYear(name) {
  currentYear = name;
  const d = getYearData(); // Get the year data for the newly selected year

  if (d) {
    // Calculate total opening stock value from stock items
    let totalOpeningStockValue = 0;
    if (d.stockItems) {
      d.stockItems.forEach(item => {
        // Use averageCost if available, otherwise fallback to openingRate
        const cost = item.averageCost !== undefined ? item.averageCost : (item.openingRate || 0);
        totalOpeningStockValue += (item.openingQty || 0) * cost;
      });
    }

    // Find the Stock-in-Hand ledger and update its opening balance
    const stockInHandLedger = d.ledgers.find(l => l.name === 'Stock-in-Hand');
    if (stockInHandLedger) {
      stockInHandLedger.openingBalance = totalOpeningStockValue;
    } else {
      // Fallback: If Stock-in-Hand ledger doesn't exist (shouldn't happen with addYear updates), create it.
      d.ledgers.push({ name: 'Stock-in-Hand', group: 'Current Assets', openingBalance: totalOpeningStockValue });
    }
  }

  save(); renderYears(); updateHeader();
  showScreen('voucherScreen'); // Or any other default screen after year selection
  notifySuccess(`Financial Year "${name}" selected.`);
}

function editYear(oldName) {
    showInputConfirmation(`Edit Financial Year`, `Enter new name for "${oldName}" (YYYY-YY):`, oldName, (newName) => {
        newName = newName.trim();
        if (!newName) {
            notifyError("New year name cannot be empty.");
            return;
        }
        if (!newName.match(/^\d{4}-\d{2}$/)) {
            notifyError("New year format must beYYYY-YY (e.g., 2024-25).");
            return;
        }
        if (newName === oldName) {
            notifyError("New name is the same as the old name.");
            return;
        }
        const company = data.companies[currentCompany];
        if (company.years[newName]) {
            notifyError(`Financial Year "${newName}" already exists.`);
            return;
        }

        // Perform the rename: copy data to new key, then delete old key
        company.years[newName] = company.years[oldName];
        delete company.years[oldName];

        if (currentYear === oldName) {
            currentYear = newName;
        }
        save();
        renderYears();
        updateHeader();
        notifySuccess(`Financial Year "${oldName}" renamed to "${newName}".`);
    });
}

function deleteYear(name) {
  showConfirmation(`Are you sure you want to delete financial year "${name}" and all its data within "${currentCompany}"?`, () => {
    const company = data.companies[currentCompany];
    if (company && company.years) {
        delete company.years[name];
        if (currentYear === name) {
            currentYear = ''; // Deselect if current year is deleted
        }
        save(); renderYears(); updateHeader();
        notifySuccess(`Financial year "${name}" deleted.`);
    }
  });
}

function renderYears() {
  const ul = document.getElementById('yearList');
  ul.innerHTML = '';
  if (!currentCompany || !data.companies[currentCompany]) return;

  const yData = data.companies[currentCompany].years;
  for (let y in yData) {
    const li = document.createElement('li');
    const textSpan = document.createElement('span');
    textSpan.textContent = y + (y === currentYear ? ' (Selected)' : '');
    li.appendChild(textSpan);
    
    const btnDiv = document.createElement('div');
    btnDiv.classList.add('action-buttons'); // Add class for styling
    
    // Select button
    const selBtn = document.createElement('button');
    selBtn.textContent = 'Select';
    selBtn.onclick = (e) => { e.stopPropagation(); selectYear(y); };
    btnDiv.appendChild(selBtn); 

    // Edit button
    const editBtn = document.createElement('span');
    editBtn.textContent = '🪶';
    editBtn.className = 'edit-btn';
    editBtn.onclick = (e) => { e.stopPropagation(); editYear(y); };
    btnDiv.appendChild(editBtn);

    // Delete button
    const delBtn = document.createElement('span');
    delBtn.textContent = '⛔';
    delBtn.className = 'delete-btn';
    delBtn.onclick = (e) => { e.stopPropagation(); deleteYear(y); };
    btnDiv.appendChild(delBtn); 
    
    li.appendChild(btnDiv);
    ul.appendChild(li);
  }
}

function getYearData() {
  if (!currentCompany || !currentYear || !data.companies[currentCompany] || !data.companies[currentCompany].years[currentYear]) {
    return null;
  }
  const yearData = data.companies[currentCompany].years[currentYear];
  // Ensure all necessary arrays exist for the current year
  if (!yearData.groups) yearData.groups = [...defaultGroups];
  if (!yearData.ledgers) yearData.ledgers = [];
  if (!yearData.vouchers) yearData.vouchers = [];
  if (!yearData.stockGroups) yearData.stockGroups = [];
  if (!yearData.stockCategories) yearData.stockCategories = [];
  if (!yearData.godowns) yearData.godowns = []; // SKUs
  if (!yearData.stockItems) yearData.stockItems = [];
  if (!yearData.stockAdjustments) yearData.stockAdjustments = [];
  
  // Ensure openingBalance for ledgers after retrieving yearData
  if (yearData.ledgers) {
      yearData.ledgers.forEach(ledger => {
          if (ledger.openingBalance === undefined) {
              ledger.openingBalance = 0;
          }
          // Ensure critical ledgers have correct groups
          if (ledger.name === 'Stock-in-Hand' && ledger.group !== 'Current Assets') {
              ledger.group = 'Current Assets';
          }
          if (ledger.name === 'Cost of Goods Sold' && ledger.group !== 'Indirect Expenses') {
              ledger.group = 'Indirect Expenses';
          }
          if (ledger.name === 'Stock Adjustment Account' && ledger.group !== 'Indirect Expenses') {
              ledger.group = 'Indirect Expenses';
          }
      });
  }
  
  // --- RECALCULATE currentQty and averageCost for all stock items ---
  // Create a temporary map to store current calculated state of each item
  const tempStockState = {};
  yearData.stockItems.forEach(item => {
    tempStockState[item.name] = {
      currentQty: item.openingQty,
      averageCost: item.openingRate
    };
  });

  // Process all vouchers chronologically to update stock state
  const sortedVouchers = [...yearData.vouchers].sort((a,b) => new Date(a.date) - new Date(b.date));
  sortedVouchers.forEach(v => {
    if (v.inventoryDetails) { // Only process vouchers with inventory details
      const itemState = tempStockState[v.inventoryDetails.itemName];
      if (itemState) { // Ensure item exists in tempStockState
        if (v.type === 'Purchase') {
            const oldTotalValue = itemState.currentQty * itemState.averageCost;
            const newPurchaseValue = v.inventoryDetails.value; // Use the value stored in voucher
            const newTotalQuantity = itemState.currentQty + v.inventoryDetails.quantity;
            if (newTotalQuantity > 0) {
                itemState.averageCost = (oldTotalValue + newPurchaseValue) / newTotalQuantity;
            } else {
                itemState.averageCost = 0; // If quantity becomes 0, average cost becomes 0
            }
            itemState.currentQty += v.inventoryDetails.quantity;
        } else if (v.type === 'Sales') {
            itemState.currentQty -= v.inventoryDetails.quantity;
            // Average cost is not affected by sales, only quantity changes
        }
      }
    }
  });

  // Process all stock adjustments chronologically
  const sortedAdjustments = [...yearData.stockAdjustments].sort((a,b) => new Date(a.date) - new Date(b.date));
  sortedAdjustments.forEach(adj => {
    const itemState = tempStockState[adj.itemName];
    if (itemState) {
        itemState.currentQty += adj.adjustedBy;
    }
  });

  // Update the actual stockItems in yearData with the calculated values
  yearData.stockItems.forEach(item => {
    const calculatedState = tempStockState[item.name];
    if (calculatedState) {
      item.currentQty = calculatedState.currentQty;
      item.averageCost = calculatedState.averageCost;
    }
    // Ensure currentQty doesn't go below zero due to calculation errors or data inconsistencies
    if (item.currentQty < 0) {
        item.currentQty = 0; // Cap at zero for display/report purposes
    }
  });

  return yearData;
}

function addGroup() {
  const name = document.getElementById('groupName').value.trim();
  const d = getYearData();
  if (!d) return notifyError("Select company & year.");
  if (!name) return notifyError("Group name is required.");
  if (d.groups.includes(name)) return notifyError(`Group "${name}" already exists.`);
  d.groups.push(name);
  save(); renderGroups();
  notifySuccess(`Group "${name}" added successfully!`);
  document.getElementById('groupName').value = '';
}
function renderGroups() {
  const ul = document.getElementById('groupList');
  const d = getYearData();
  ul.innerHTML = '';
  const ledgerGroupSelect = document.getElementById('ledgerGroup');
  ledgerGroupSelect.innerHTML = '<option value="">Select Group...</option>';
  if (!d) return;
  d.groups.sort().forEach((g, i) => { // Sort groups alphabetically
    const li = document.createElement('li');
    li.textContent = g;
    // Only allow deletion of non-default groups
    if (!defaultGroups.includes(g)) {
      const delBtn = document.createElement('span');
      delBtn.textContent = '❌';
      delBtn.className = 'delete-btn';
      delBtn.onclick = () => {
        showConfirmation(`Are you sure you want to delete group "${g}"? Ledgers under this group will become ungrouped.`, () => {
            // Remove group
            const groupIndex = d.groups.indexOf(g);
            if (groupIndex > -1) d.groups.splice(groupIndex, 1);
            
            // Reassign ledgers under this group to a "Uncategorized" group or similar, or just keep them with a non-existent group (less ideal)
            d.ledgers.forEach(ledger => {
                if (ledger.group === g) {
                    ledger.group = 'Uncategorized'; // Or another default
                    if (!d.groups.includes('Uncategorized')) {
                        d.groups.push('Uncategorized'); // Add if it doesn't exist
                    }
                }
            });
            save();
            renderGroups();
            renderLedgers(); // Re-render ledgers to show group changes
            notifySuccess(`Group "${g}" deleted.`);
        });
      };
      li.appendChild(delBtn);
    }
    ul.appendChild(li);

    const opt = document.createElement('option');
    opt.value = g;
    opt.textContent = g;
    ledgerGroupSelect.appendChild(opt);
  });
}


function addLedger() {
  const name = document.getElementById('ledgerName').value.trim();
  const group = document.getElementById('ledgerGroup').value;
  const openingBalanceInput = document.getElementById('openingBalance').value;
  const openingBalance = parseFloat(openingBalanceInput) || 0; // Default to 0 if not a valid number or empty

  const d = getYearData();
  if (!d) return notifyError("Select company & year.");
  if (!name) return notifyError("Ledger name is required.");
  if (!group) return notifyError("Please select a group for the ledger.");
  if (d.ledgers.find(l => l.name.toLowerCase() === name.toLowerCase())) return notifyError(`Ledger "${name}" already exists.`);

  d.ledgers.push({ name, group, openingBalance });
  save(); renderLedgers();
  notifySuccess(`Ledger "${name}" added successfully!`);
  document.getElementById('ledgerName').value = '';
  document.getElementById('ledgerGroup').value = '';
  document.getElementById('openingBalance').value = ''; // Clear opening balance input
}
function renderLedgers() {
  const ul = document.getElementById('ledgerList');
  const d = getYearData();
  ul.innerHTML = '';
  if (!d) return;
  const nonDeletableLedgers = ['Stock-in-Hand', 'Cost of Goods Sold', 'Stock Adjustment Account']; // Make these non-deletable
  d.ledgers.sort((a,b) => a.name.localeCompare(b.name)).forEach((l, i) => { // Sort ledgers
    const li = document.createElement('li');
    let ledgerText = `${l.name} (${l.group})`;
    if (l.openingBalance && l.openingBalance !== 0) {
        ledgerText += ` (Opening Bal: ₹${l.openingBalance.toFixed(2)})`;
    }
    li.textContent = ledgerText;

    // Only allow deletion of non-default ledgers
    if (!nonDeletableLedgers.includes(l.name)) {
      const delBtn = document.createElement('span');
      delBtn.textContent = '❌';
      delBtn.className = 'delete-btn';
      delBtn.onclick = () => {
        showConfirmation(`Are you sure you want to delete ledger "${l.name}"? This might affect vouchers.`, () => {
          // Find the original index before sorting if needed for splice, or filter it out
          const originalIndex = d.ledgers.findIndex(ledger => ledger.name === l.name && ledger.group === l.group);
          if (originalIndex > -1) d.ledgers.splice(originalIndex, 1);
          save(); renderLedgers(); populateLedgerDropdownsForVoucher(); showReports();
          notifySuccess(`Ledger "${l.name}" deleted.`);
        });
      };
      li.appendChild(delBtn);
    }
    ul.appendChild(li);
  });
  populateLedgerDropdownsForVoucher();
}

function populateLedgerDropdownsForVoucher() {
  const d = getYearData();
  const debitSelect = document.getElementById('debit');
  const creditSelect = document.getElementById('credit');
  debitSelect.innerHTML = '<option value="">Select Debit Ledger...</option>';
  creditSelect.innerHTML = '<option value="">Select Credit Ledger...</option>';
  if (!d || !d.ledgers) return;
  d.ledgers.sort((a,b) => a.name.localeCompare(b.name)).forEach(l => {
    const optDr = document.createElement('option');
    optDr.value = l.name;
    optDr.textContent = l.name;
    debitSelect.appendChild(optDr);

    const optCr = document.createElement('option');
    optCr.value = l.name;
    optCr.textContent = l.name;
    creditSelect.appendChild(optCr);
  });
}

function resetVoucherForm() {
    currentVoucherId = null;
    document.getElementById('debit').value = '';
    document.getElementById('credit').value = '';
    document.getElementById('amount').value = '';
    document.getElementById('voucherDate').valueAsDate = new Date();
    document.getElementById('voucherType').value = 'Purchase'; // Default to Purchase
    document.getElementById('narration').value = '';
    document.getElementById('voucherStockItem').value = '';
    document.getElementById('voucherStockQuantity').value = '';
    document.getElementById('voucherPricePerUnit').value = '';
    document.getElementById('amount').readOnly = false; // Reset to editable
    document.getElementById('addVoucherBtn').textContent = 'Add Voucher';
    document.getElementById('addVoucherBtn').onclick = addVoucher;
    handleVoucherTypeChange(); // Re-apply visibility rules
}

function addVoucher() {
  const debit = document.getElementById('debit').value;
  const credit = document.getElementById('credit').value;
  let amount = parseFloat(document.getElementById('amount').value); // This will now be auto-calculated for inventory vouchers
  const date = document.getElementById('voucherDate').value;
  const type = document.getElementById('voucherType').value;
  const narration = document.getElementById('narration').value.trim();

  const d = getYearData(); // Get fresh year data with recalculated stock
  if (!d) return notifyError("Select company & year.");
  if (!debit || !credit || !date || !type) return notifyError("All voucher fields (except narration) are required.");
  if (isNaN(amount) || amount <= 0) return notifyError("Amount must be a positive number.");
  if (debit === credit) return notifyError("Debit and Credit ledgers cannot be the same.");

  let actualDebit = debit; // Will hold the ledger actually debited
  let actualCredit = credit; // Will hold the ledger actually credited
  let voucherAmount = amount; // Will hold the primary voucher amount

  let inventoryUpdatePerformed = false;
  let costOfGoodsSoldAmount = 0; // To track COGS for sales

  let newVoucherInventoryDetails = null;

  if (type === 'Sales' || type === 'Purchase') {
    const stockItemName = document.getElementById('voucherStockItem').value;
    const stockQuantity = parseFloat(document.getElementById('voucherStockQuantity').value);
    const pricePerUnit = parseFloat(document.getElementById('voucherPricePerUnit').value); // Used for calculation

    if (!stockItemName) return notifyError("Please select a stock item for Sales/Purchase voucher.");
    if (isNaN(stockQuantity) || stockQuantity <= 0) return notifyError("Stock quantity must be a positive number.");
    // Validate pricePerUnit for Purchase
    if (type === 'Purchase' && (isNaN(pricePerUnit) || pricePerUnit <= 0)) return notifyError("Price per unit is required for Purchase vouchers.");
    // Validate pricePerUnit for Sales
    if (type === 'Sales' && (isNaN(pricePerUnit) || pricePerUnit <= 0)) return notifyError("Sales price per unit is required for Sales vouchers.");


    const itemToUpdate = d.stockItems.find(item => item.name === stockItemName);
    if (!itemToUpdate) return notifyError("Selected stock item not found in master.");

    // Note: currentQty and averageCost are now recalculated in getYearData().
    // So, we just need to apply the *new* transaction's effect.

    voucherAmount = stockQuantity * pricePerUnit; // The calculated amount for the voucher

    if (type === 'Sales') {
      if (itemToUpdate.currentQty < stockQuantity) {
        return notifyError(`Not enough stock for ${stockItemName}. Available: ${itemToUpdate.currentQty} ${itemToUpdate.unit}.`);
      }
      
      // Calculate Cost of Goods Sold using the current average cost of the item
      costOfGoodsSoldAmount = stockQuantity * itemToUpdate.averageCost; 
      
      // Ensure 'Cost of Goods Sold' ledger exists or create it if not in default groups
      if (!d.ledgers.some(l => l.name === 'Cost of Goods Sold')) {
          d.ledgers.push({ name: 'Cost of Goods Sold', group: 'Indirect Expenses', openingBalance: 0 });
          save(); // Save ledgers immediately to ensure it's available for next voucher push
      }

    } else { // Purchase
      // For Purchase: The amount of the voucher should directly debit 'Stock-in-Hand'
      actualDebit = 'Stock-in-Hand'; 
      actualCredit = credit; // Original credit ledger (Cash, Creditors)
    }
    // Add inventory details to the primary voucher for display purposes
    newVoucherInventoryDetails = { itemName: stockItemName, quantity: stockQuantity, value: voucherAmount };
    inventoryUpdatePerformed = true;
  } 
  
  const newVoucherId = Date.now(); // Generate ID for the main voucher
  d.vouchers.push({ id: newVoucherId, date, type, debit: actualDebit, credit: actualCredit, amount: voucherAmount, narration: narration.substring(0, 200), inventoryDetails: newVoucherInventoryDetails });

  // If it was a sale, add the COGS entry separately
  if (type === 'Sales' && costOfGoodsSoldAmount > 0) {
      console.log("Creating Journal (COGS) voucher for:", newVoucherInventoryDetails.itemName);
      console.log("COGS Amount:", costOfGoodsSoldAmount);
      d.vouchers.push({
          id: Date.now() + Math.random(), // Ensure unique ID for COGS voucher, different from main voucher
          date: date,
          type: 'Journal (COGS)', // Specific type for clarity
          debit: 'Cost of Goods Sold',
          credit: 'Stock-in-Hand',
          amount: costOfGoodsSoldAmount,
          narration: `Cost of goods sold for ${newVoucherInventoryDetails.itemName} (Qty: ${newVoucherInventoryDetails.quantity})`,
          relatedVoucherId: newVoucherId // Link to the main sales voucher
      });
  }

  save();
  // Re-render everything that depends on recalculated stock data
  renderVouchers();
  showReports();
  renderDaybook();
  renderStockItems(); // Refresh stock master view
  populateVoucherStockItemDropdown(); // Refresh dropdown in voucher screen
  populateAdjustmentItemDropdown(); // Refresh stock adjustment dropdown

  notifySuccess("Voucher added successfully!");
  resetVoucherForm();
}

function editVoucher(id) {
    const d = getYearData();
    if (!d) return;
    const voucher = d.vouchers.find(v => v.id === id);
    if (!voucher) return notifyError("Voucher not found for editing.");

    currentVoucherId = id; // Set the ID of the voucher being edited

    // Populate form fields
    document.getElementById('debit').value = voucher.debit;
    document.getElementById('credit').value = voucher.credit;
    document.getElementById('amount').value = voucher.amount;
    document.getElementById('voucherDate').value = voucher.date;
    document.getElementById('voucherType').value = voucher.type;
    document.getElementById('narration').value = voucher.narration;

    // Handle inventory section visibility and population
    handleVoucherTypeChange(); // Call this to set up display based on voucher type
    if (voucher.inventoryDetails) {
        document.getElementById('voucherStockItem').value = voucher.inventoryDetails.itemName;
        document.getElementById('voucherStockQuantity').value = voucher.inventoryDetails.quantity;
        // For editing, if it's a sales/purchase, the pricePerUnit is directly the amount / quantity
        if (voucher.inventoryDetails.quantity > 0) {
            document.getElementById('voucherPricePerUnit').value = (voucher.inventoryDetails.value / voucher.inventoryDetails.quantity).toFixed(2);
        } else {
            document.getElementById('voucherPricePerUnit').value = '';
        }
    } else {
        // Clear inventory fields if not an inventory voucher
        document.getElementById('voucherStockItem').value = '';
        document.getElementById('voucherStockQuantity').value = '';
        document.getElementById('voucherPricePerUnit').value = '';
    }

    // Change button to Update mode
    const addVoucherBtn = document.getElementById('addVoucherBtn');
    addVoucherBtn.textContent = 'Update Voucher';
    addVoucherBtn.onclick = () => updateVoucher(id);
}

function updateVoucher(id) {
    const d = getYearData(); // Get fresh year data before making changes
    if (!d) return;

    const voucherIndex = d.vouchers.findIndex(v => v.id === id);
    if (voucherIndex === -1) return notifyError("Voucher not found for updating.");

    // Remove the original voucher and its related COGS entry before adding the updated one
    // This simplifies the logic by treating update as delete + add
    const originalVoucher = { ...d.vouchers[voucherIndex] }; // Make a copy
    d.vouchers.splice(voucherIndex, 1); // Remove original voucher

    // Remove related COGS entry if it exists and was linked to this original voucher
    const cogsVoucherIndex = d.vouchers.findIndex(v => 
        v.type === 'Journal (COGS)' && v.relatedVoucherId === id
    );
    if (cogsVoucherIndex > -1) {
        d.vouchers.splice(cogsVoucherIndex, 1);
    }

    // Now, add the new voucher with updated details (similar to addVoucher)
    const newDebit = document.getElementById('debit').value;
    const newCredit = document.getElementById('credit').value;
    let newAmount = parseFloat(document.getElementById('amount').value); // Will be recalculated for inventory
    const newDate = document.getElementById('voucherDate').value;
    const newType = document.getElementById('voucherType').value;
    const newNarration = document.getElementById('narration').value.trim();

    if (!newDebit || !newCredit || !newDate || !newType) return notifyError("All voucher fields (except narration) are required.");
    if (isNaN(newAmount) || newAmount <= 0) return notifyError("Amount must be a positive number.");
    if (newDebit === newCredit) return notifyError("Debit and Credit ledgers cannot be the same.");

    // Validate Stock-in-Hand ledger usage for the updated voucher
    if (newDebit === 'Stock-in-Hand' || newCredit === 'Stock-in-Hand') {
        if (!['Purchase', 'Sales', 'Journal (COGS)', 'Journal (Stock Adj)'].includes(newType)) {
            // Re-add the original voucher if the new one is invalid
            d.vouchers.splice(voucherIndex, 0, originalVoucher);
            return notifyError("Stock-in-Hand ledger can only be affected by Purchase, Sales, or Stock Adjustment vouchers.");
        }
    }

    let newVoucherInventoryDetails = null;
    let newCostOfGoodsSoldAmount = 0;

    if (newType === 'Sales' || newType === 'Purchase') {
        const newStockItemName = document.getElementById('voucherStockItem').value;
        const newStockQuantity = parseFloat(document.getElementById('voucherStockQuantity').value);
        const newPricePerUnit = parseFloat(document.getElementById('voucherPricePerUnit').value);

        if (!newStockItemName) return notifyError("Please select a stock item for Sales/Purchase voucher.");
        if (isNaN(newStockQuantity) || newStockQuantity <= 0) return notifyError("Stock quantity must be a positive number.");
        if (newType === 'Purchase' && (isNaN(newPricePerUnit) || newPricePerUnit <= 0)) return notifyError("Price per unit is required for Purchase vouchers.");
        if (newType === 'Sales' && (isNaN(newPricePerUnit) || newPricePerUnit <= 0)) return notifyError("Sales price per unit is required for Sales vouchers.");

        const newItemToUpdate = d.stockItems.find(item => item.name === newStockItemName);
        if (!newItemToUpdate) return notifyError("Selected stock item not found in master.");

        // Recalculate amount based on new inputs
        newAmount = newStockQuantity * newPricePerUnit;

        newVoucherInventoryDetails = { itemName: newStockItemName, quantity: newStockQuantity, value: newAmount };

        if (newType === 'Sales') {
            // Recalculate yearData *after* removing the old voucher, *before* checking stock for the new one
            const updatedYearData = getYearData(); // Get fresh data to ensure accurate currentQty
            const currentItemState = updatedYearData.stockItems.find(item => item.name === newStockItemName); 

            if (currentItemState.currentQty < newStockQuantity) {
                 // Re-add the original voucher if the new one cannot be processed
                d.vouchers.splice(voucherIndex, 0, originalVoucher); // Add back at original position
                notifyError(`Not enough stock for ${newStockItemName}. Available: ${currentItemState.currentQty} ${currentItemState.unit}. Cannot update.`);
                return;
            }
            newCostOfGoodsSoldAmount = newStockQuantity * newItemToUpdate.averageCost; // Use item's current average cost
        }
    }

    // Add the updated main voucher
    d.vouchers.push({
        id: id, // Keep the original ID
        date: newDate,
        type: newType,
        debit: newDebit,
        credit: newCredit,
        amount: newAmount,
        narration: newNarration.substring(0, 200),
        inventoryDetails: newVoucherInventoryDetails
    });

    // Add the new COGS entry if applicable
    if (newType === 'Sales' && newCostOfGoodsSoldAmount > 0) {
        console.log("Creating Journal (COGS) voucher during update for:", newVoucherInventoryDetails.itemName);
        console.log("COGS Amount:", newCostOfGoodsSoldAmount);
        d.vouchers.push({
            id: Date.now() + Math.random(), // New unique ID for the new COGS voucher
            date: newDate,
            type: 'Journal (COGS)',
            debit: 'Cost of Goods Sold',
            credit: 'Stock-in-Hand',
            amount: newCostOfGoodsSoldAmount,
            narration: `Cost of goods sold for ${newVoucherInventoryDetails.itemName} (Qty: ${newVoucherInventoryDetails.quantity})`,
            relatedVoucherId: id // Link to the original sales voucher ID
        });
    }

    save();
    // Re-render everything that depends on recalculated stock data
    renderVouchers();
    showReports();
    renderDaybook();
    renderStockItems(); // Refresh stock master view
    populateVoucherStockItemDropdown(); // Refresh dropdown in voucher screen
    populateAdjustmentItemDropdown(); // Refresh stock adjustment dropdown

    notifySuccess("Voucher updated successfully!");
    resetVoucherForm();
}


function deleteVoucher(id) {
  showConfirmation(`Are you sure you want to delete this voucher? This will reverse its impact on ledgers and stock.`, () => {
    const d = getYearData(); // Get fresh year data before making changes
    if (!d) return;

    const voucherIndex = d.vouchers.findIndex(v => v.id === id);
    if (voucherIndex === -1) {
        console.error("Voucher not found for deletion.");
        notifyError("Voucher not found for deletion.");
        return;
    }

    const voucherToDelete = d.vouchers[voucherIndex];

    // Remove the primary voucher
    d.vouchers.splice(voucherIndex, 1);

    // Remove related COGS entry if it exists and was linked to this voucher
    const cogsVoucherIndex = d.vouchers.findIndex(v => 
        v.type === 'Journal (COGS)' && v.relatedVoucherId === id
    );
    if (cogsVoucherIndex > -1) {
        d.vouchers.splice(cogsVoucherIndex, 1);
    }

    save();
    // Re-render everything that depends on recalculated stock data
    renderVouchers();
    showReports();
    renderDaybook();
    renderStockItems(); // Refresh stock master view
    populateVoucherStockItemDropdown(); // Refresh dropdown in voucher screen
    populateAdjustmentItemDropdown(); // Refresh stock adjustment dropdown
    notifySuccess("Voucher deleted.");
    resetVoucherForm();
  });
}


function renderVouchers() {
  const ul = document.getElementById('voucherList');
  const d = getYearData();
  ul.innerHTML = '';
  if (!d) return;
  d.vouchers.sort((a,b) => new Date(b.date) - new Date(a.date)).forEach((v) => { // Show newest first
    const li = document.createElement('li');
    let voucherText = `${v.date} [${v.type}] ${v.debit} Dr / ${v.credit} Cr = ₹${v.amount.toFixed(2)}`;
    if (v.inventoryDetails) {
        voucherText += ` (Item: ${v.inventoryDetails.itemName}, Qty: ${v.inventoryDetails.quantity})`;
    }
    if(v.narration) voucherText += ` <small><i>${v.narration}</i></small>`;
    const textSpan = document.createElement('span');
    textSpan.innerHTML = voucherText; // Use innerHTML to render small tag
    li.appendChild(textSpan);

    const btnDiv = document.createElement('div');
    btnDiv.classList.add('action-buttons');

    // Edit button
    // Only allow editing of main vouchers, not auto-generated COGS/Stock Adj journals
    if (!v.type.includes('Journal (COGS)') && !v.type.includes('Journal (Stock Adj)')) {
        const editBtn = document.createElement('span');
        editBtn.textContent = '🪶';
        editBtn.className = 'edit-btn';
        editBtn.onclick = (e) => { e.stopPropagation(); editVoucher(v.id); };
        btnDiv.appendChild(editBtn);
    }

    const delBtn = document.createElement('span');
    delBtn.textContent = '⛔';
    delBtn.className = 'delete-btn';
    delBtn.onclick = (e) => { e.stopPropagation(); deleteVoucher(v.id); };
    btnDiv.appendChild(delBtn); 
    
    li.appendChild(btnDiv);
    ul.appendChild(li);
  });
}

// --- Stock Master Functions ---
function addStockGroup() {
  const name = document.getElementById('stockGroupName').value.trim();
  const d = getYearData();
  if (!d) return notifyError("Select company & year.");
  if (!name) return notifyError("Enter a stock group name.");
  if (d.stockGroups.includes(name)) return notifyError("Stock group already exists.");
  d.stockGroups.push(name);
  save(); renderStockGroups();
  document.getElementById('stockGroupName').value = '';
  notifySuccess("Stock group added.");
}
function renderStockGroups() {
  const ul = document.getElementById('stockGroupList');
  const sel = document.getElementById('stockGroupSelect');
  const d = getYearData();
  ul.innerHTML = '';
  sel.innerHTML = '<option value="">Select Stock Group...</option>';
  if (!d) return;
  d.stockGroups.sort().forEach((g, i) => {
    const li = document.createElement('li');
    li.textContent = g;
    const delBtn = document.createElement('span');
    delBtn.textContent = '❌';
    delBtn.className = 'delete-btn';
    delBtn.onclick = () => {
      showConfirmation(`Are you sure you want to delete stock group "${g}"?`, () => {
        d.stockGroups.splice(i, 1);
        save(); renderStockGroups();
        notifySuccess("Stock group deleted.");
      });
    };
    li.appendChild(delBtn);
    ul.appendChild(li);

    const opt = document.createElement('option');
    opt.value = g;
    opt.textContent = g;
    sel.appendChild(opt);
  });
}

function addStockCategory() {
  const name = document.getElementById('stockCategoryName').value.trim();
  const d = getYearData();
  if (!d) return notifyError("Select company & year.");
  if (!name) return notifyError("Enter a stock category name.");
  if (d.stockCategories.includes(name)) return notifyError("Stock category already exists.");
  d.stockCategories.push(name);
  save(); renderStockCategories();
  document.getElementById('stockCategoryName').value = '';
  notifySuccess("Stock category added.");
}
function renderStockCategories() {
  const ul = document.getElementById('stockCategoryList');
  const sel = document.getElementById('stockCategorySelect');
  const d = getYearData();
  ul.innerHTML = '';
  sel.innerHTML = '<option value="">Select Stock Category...</option>';
  if (!d) return;
  d.stockCategories.sort().forEach((c, i) => {
    const li = document.createElement('li');
    li.textContent = c;
    const delBtn = document.createElement('span');
    delBtn.textContent = '❌';
    delBtn.className = 'delete-btn';
    delBtn.onclick = () => {
      showConfirmation(`Are you sure you want to delete stock category "${c}"?`, () => {
        d.stockCategories.splice(i, 1);
        save(); renderStockCategories();
        notifySuccess("Stock category deleted.");
      });
    };
    li.appendChild(delBtn);
    ul.appendChild(li);

    const opt = document.createElement('option');
    opt.value = c;
    opt.textContent = c;
    sel.appendChild(opt);
  });
}

function addSKU() { // Renamed from addGodown to align with 'SKU' text
  const name = document.getElementById('skuName').value.trim();
  const d = getYearData();
  if (!d) return notifyError("Select company & year.");
  if (!name) return notifyError("Enter a SKU/Location name.");
  if (d.godowns.includes(name)) return notifyError("SKU/Location already exists.");
  d.godowns.push(name);
  save(); renderSKUs();
  document.getElementById('skuName').value = '';
  notifySuccess("SKU/Location added.");
}
function renderSKUs() { // Renamed from renderGodowns
  const ul = document.getElementById('skuList');
  const sel = document.getElementById('stockSKUSelect');
  const d = getYearData();
  ul.innerHTML = '';
  sel.innerHTML = '<option value="">Select SKU/Location...</option>';
  if (!d) return;
  d.godowns.sort().forEach((s, i) => {
    const li = document.createElement('li');
    li.textContent = s;
    const delBtn = document.createElement('span');
    delBtn.textContent = '❌';
    delBtn.className = 'delete-btn';
    delBtn.onclick = () => {
      showConfirmation(`Are you sure you want to delete SKU/Location "${s}"?`, () => {
        d.godowns.splice(i, 1);
        save(); renderSKUs();
        notifySuccess("SKU/Location deleted.");
      });
    };
    li.appendChild(delBtn);
    ul.appendChild(li);

    const opt = document.createElement('option');
    opt.value = s;
    opt.textContent = s;
    sel.appendChild(opt);
  });
}

function addStockItem() {
  const d = getYearData();
  if (!d) return notifyError("Select company & year.");

  const name = document.getElementById('stockItemName').value.trim();
  const group = document.getElementById('stockGroupSelect').value;
  const category = document.getElementById('stockCategorySelect').value;
  const unit = document.getElementById('stockUnit').value.trim();
  const godown = document.getElementById('stockSKUSelect').value; // SKU
  const openingQty = parseFloat(document.getElementById('stockOpeningQty').value);
  const openingRate = parseFloat(document.getElementById('stockOpeningRate').value); // This is now the primary input for rate

  if (!name || !group || !category || !unit || !godown) return notifyError("All stock item fields are required.");
  if (isNaN(openingQty) || openingQty < 0) return notifyError("Opening quantity must be a non-negative number.");
  if (isNaN(openingRate) || openingRate < 0) return notifyError("Opening rate must be a non-negative number."); // Validate openingRate directly
  
  if (d.stockItems.find(item => item.name.toLowerCase() === name.toLowerCase())) return notifyError(`Stock item "${name}" already exists.`);

  // Initialize currentQty and averageCost with opening values
  d.stockItems.push({ name, group, category, unit, godown, openingQty, openingRate, currentQty: openingQty, averageCost: openingRate });
  save(); renderStockItems(); populateVoucherStockItemDropdown(); populateAdjustmentItemDropdown();
  notifySuccess(`Stock item "${name}" added.`);
  // Clear form
  document.getElementById('stockItemName').value = '';
  document.getElementById('stockUnit').value = '';
  document.getElementById('stockOpeningQty').value = '';
  document.getElementById('stockOpeningRate').value = '';
  document.getElementById('stockOpeningValue').value = ''; // Clear calculated value
}
function renderStockItems() {
  const ul = document.getElementById('stockItemList');
  const d = getYearData(); // Get fresh data to ensure currentQty and averageCost are up-to-date
  ul.innerHTML = '';
  if (!d) return;
  d.stockItems.sort((a,b) => a.name.localeCompare(b.name)).forEach((item, i) => {
    const li = document.createElement('li');
    // currentQty and averageCost are now guaranteed to be calculated by getYearData()
    const currentQty = item.currentQty;
    const averageCost = item.averageCost; 
    li.textContent = `${item.name} (${item.group}/${item.category}/${item.godown}, Unit: ${item.unit}, Opening: ${item.openingQty}, Current: ${currentQty}, Avg Cost: ₹${averageCost.toFixed(2)})`;
    
    const delBtn = document.createElement('span');
    delBtn.textContent = '❌';
    delBtn.className = 'delete-btn';
    delBtn.onclick = () => {
      showConfirmation(`Are you sure you want to delete stock item "${item.name}"? This will affect related vouchers.`, () => {
        d.stockItems.splice(i, 1);
        // Also remove inventory details from vouchers related to this item
        d.vouchers.forEach(v => {
            if (v.inventoryDetails && v.inventoryDetails.itemName === item.name) {
                v.inventoryDetails = null; // Clear inventory details for this item
            }
        });
        save(); renderStockItems(); populateVoucherStockItemDropdown(); populateAdjustmentItemDropdown();
        renderVouchers(); // Refresh vouchers to reflect cleared inventory details
        notifySuccess(`Stock item "${item.name}" deleted.`);
      });
    };
    li.appendChild(delBtn);
    ul.appendChild(li);
  });
}

// --- Stock Adjustment Functions (formerly Inventory Screen) ---
function populateAdjustmentItemDropdown() {
    const d = getYearData();
    const select = document.getElementById('adjustmentItemName');
    select.innerHTML = '<option value="">Select Stock Item...</option>';
    if (!d || !d.stockItems) return;
    d.stockItems.sort((a,b) => a.name.localeCompare(b.name)).forEach(item => {
        const currentQty = item.currentQty; // Use the recalculated currentQty
        const opt = document.createElement('option');
        opt.value = item.name;
        opt.textContent = `${item.name} (Current Qty: ${currentQty} ${item.unit})`;
        select.appendChild(opt);
    });
}

function resetAdjustmentForm() {
    currentAdjustmentId = null;
    document.getElementById('adjustmentItemName').value = '';
    document.getElementById('adjustmentQuantity').value = '';
    document.getElementById('adjustmentReason').value = '';
    document.getElementById('adjustStockBtn').textContent = 'Adjust Stock';
    document.getElementById('adjustStockBtn').onclick = performStockAdjustment;
}

function performStockAdjustment() {
    const d = getYearData(); // Get fresh year data
    if (!d) return notifyError("Select company and year first.");

    const itemName = document.getElementById('adjustmentItemName').value;
    const adjustmentQty = parseFloat(document.getElementById('adjustmentQuantity').value);
    const reason = document.getElementById('adjustmentReason').value.trim();

    if (!itemName) return notifyError("Select a stock item for adjustment.");
    if (isNaN(adjustmentQty)) return notifyError("Adjustment quantity must be a valid number.");
    if (adjustmentQty === 0) return notifyError("Adjustment quantity cannot be zero.");
    if (!reason) return notifyError("Reason for adjustment is required.");

    const itemToAdjust = d.stockItems.find(item => item.name === itemName);
    if (!itemToAdjust) return notifyError("Stock item not found.");

    // Check if adjustment leads to negative stock *before* adding it
    if ((itemToAdjust.currentQty + adjustmentQty) < 0) {
        return notifyError(`Adjustment results in negative stock for ${itemName}. Available: ${itemToAdjust.currentQty}`);
    }

    if (!d.stockAdjustments) d.stockAdjustments = []; // Ensure stockAdjustments array exists
    const newAdjustmentId = Date.now();
    d.stockAdjustments.push({
        id: newAdjustmentId,
        date: new Date().toISOString().split('T')[0], // Current date
        itemName,
        adjustedBy: adjustmentQty,
        reason,
        // newQty will be recalculated by getYearData when rendered
    });

    // Also create a journal voucher for the stock adjustment to affect the Stock-in-Hand ledger
    // Debit Stock-in-Hand for positive adjustments, Credit for negative
    const adjustmentType = adjustmentQty > 0 ? 'Debit' : 'Credit';
    const adjustmentNarration = `Stock adjustment for ${itemName}: ${reason}.`;
    // Use the current averageCost for the value of the adjustment
    const adjustmentAmount = Math.abs(adjustmentQty * itemToAdjust.averageCost); 

    if (adjustmentAmount > 0) { // Only create voucher if there's a value impact
        const adjustmentVoucherId = Date.now() + Math.random(); // Unique ID for the related voucher
        if (adjustmentType === 'Debit') {
            d.vouchers.push({
                id: adjustmentVoucherId,
                date: new Date().toISOString().split('T')[0],
                type: 'Journal (Stock Adj)',
                debit: 'Stock-in-Hand',
                credit: 'Stock Adjustment Account', // You might want a specific ledger for adjustments
                amount: adjustmentAmount,
                narration: adjustmentNarration,
                relatedAdjustmentId: newAdjustmentId // Link to the adjustment
            });
        } else { // Credit
            d.vouchers.push({
                id: adjustmentVoucherId,
                date: new Date().toISOString().split('T')[0],
                type: 'Journal (Stock Adj)',
                debit: 'Stock Adjustment Account', // You might want a specific ledger for adjustments
                credit: 'Stock-in-Hand',
                amount: adjustmentAmount,
                narration: adjustmentNarration,
                relatedAdjustmentId: newAdjustmentId // Link to the adjustment
            });
        }
    }
    // Ensure 'Stock Adjustment Account' ledger exists or create it
    if (!d.ledgers.some(l => l.name === 'Stock Adjustment Account')) {
        d.ledgers.push({ name: 'Stock Adjustment Account', group: 'Indirect Expenses', openingBalance: 0 }); // Or appropriate group
        save(); // Save ledgers immediately
    }


    save(); 
    // Re-render everything that depends on recalculated stock data
    renderStockItems(); 
    populateVoucherStockItemDropdown(); 
    populateAdjustmentItemDropdown(); 
    renderStockAdjustmentLog();
    showReports(); 
    renderVouchers(); // Vouchers list might have changed due to new journal entry
    notifySuccess("Stock adjusted successfully!");
    resetAdjustmentForm();
}

function editStockAdjustment(id) {
    const d = getYearData();
    if (!d) return;
    const adjustment = d.stockAdjustments.find(adj => adj.id === id);
    if (!adjustment) return notifyError("Stock adjustment not found for editing.");

    currentAdjustmentId = id;

    document.getElementById('adjustmentItemName').value = adjustment.itemName;
    document.getElementById('adjustmentQuantity').value = adjustment.adjustedBy;
    document.getElementById('adjustmentReason').value = adjustment.reason;

    const adjustStockBtn = document.getElementById('adjustStockBtn');
    adjustStockBtn.textContent = 'Update Adjustment';
    adjustStockBtn.onclick = () => updateStockAdjustment(id);
}

function updateStockAdjustment(id) {
    const d = getYearData(); // Get fresh year data
    if (!d) return;

    const adjustmentIndex = d.stockAdjustments.findIndex(adj => adj.id === id);
    if (adjustmentIndex === -1) return notifyError("Stock adjustment not found for updating.");

    // Remove the original adjustment and its related voucher before adding the updated one
    const originalAdjustment = { ...d.stockAdjustments[adjustmentIndex] };
    d.stockAdjustments.splice(adjustmentIndex, 1);

    const relatedVoucherIndex = d.vouchers.findIndex(v => v.relatedAdjustmentId === originalAdjustment.id);
    if (relatedVoucherIndex > -1) {
        d.vouchers.splice(relatedVoucherIndex, 1);
    }

    // Now, add the new adjustment with updated details (similar to performStockAdjustment)
    const newItemName = document.getElementById('adjustmentItemName').value;
    const newAdjustmentQty = parseFloat(document.getElementById('adjustmentQuantity').value);
    const newReason = document.getElementById('adjustmentReason').value.trim();

    if (!newItemName) return notifyError("Select a stock item for adjustment.");
    if (isNaN(newAdjustmentQty)) return notifyError("Adjustment quantity must be a valid number.");
    if (newAdjustmentQty === 0) return notifyError("Adjustment quantity cannot be zero.");
    if (!newReason) return notifyError("Reason for adjustment is required.");

    const newItemToAdjust = d.stockItems.find(item => item.name === newItemName);
    if (!newItemToAdjust) {
        // Re-add original adjustment if new item is invalid
        d.stockAdjustments.splice(adjustmentIndex, 0, originalAdjustment);
        notifyError("Selected stock item not found for adjustment. Update cancelled.");
        return;
    }

    // Check if adjustment leads to negative stock *after* removing original, *before* adding new
    // This is handled by getYearData() recalculating before this function runs
    const currentItemState = getYearData().stockItems.find(item => item.name === newItemName); // Get updated state
    if ((currentItemState.currentQty + newAdjustmentQty) < 0) {
        // Re-add original adjustment if the new one causes negative stock
        d.stockAdjustments.splice(adjustmentIndex, 0, originalAdjustment);
        notifyError(`Updated adjustment results in negative stock for ${newItemName}. Available: ${currentItemState.currentQty}. Cannot update.`);
        return;
    }

    d.stockAdjustments.push({
        id: id, // Keep the original ID
        date: new Date().toISOString().split('T')[0],
        itemName: newItemName,
        adjustedBy: newAdjustmentQty,
        reason: newReason,
        // newQty will be recalculated by getYearData when rendered
    });

    // Create a new journal voucher for the updated adjustment
    const adjustmentType = newAdjustmentQty > 0 ? 'Debit' : 'Credit';
    const adjustmentNarration = `Stock adjustment for ${newItemName}: ${newReason}.`;
    const adjustmentAmount = Math.abs(newAdjustmentQty * newItemToAdjust.averageCost); // Use item's current average cost

    if (adjustmentAmount > 0) {
        const newAdjustmentVoucherId = Date.now() + Math.random(); // New unique ID
        if (adjustmentType === 'Debit') {
            d.vouchers.push({
                id: newAdjustmentVoucherId,
                date: new Date().toISOString().split('T')[0],
                type: 'Journal (Stock Adj)',
                debit: 'Stock-in-Hand',
                credit: 'Stock Adjustment Account',
                amount: adjustmentAmount,
                narration: adjustmentNarration,
                relatedAdjustmentId: id // Link to the original adjustment ID
            });
        } else {
            d.vouchers.push({
                id: newAdjustmentVoucherId,
                date: new Date().toISOString().split('T')[0],
                type: 'Journal (Stock Adj)',
                debit: 'Stock Adjustment Account',
                credit: 'Stock-in-Hand',
                amount: adjustmentAmount,
                narration: adjustmentNarration,
                relatedAdjustmentId: id // Link to the original adjustment ID
            });
        }
    }

    save();
    // Re-render everything that depends on recalculated stock data
    renderStockItems();
    populateVoucherStockItemDropdown();
    populateAdjustmentItemDropdown();
    renderStockAdjustmentLog();
    showReports();
    renderVouchers(); // Vouchers list might have changed due to new journal entry

    notifySuccess("Stock adjustment updated successfully!");
    resetAdjustmentForm();
}


function deleteStockAdjustment(id) {
    showConfirmation(`Are you sure you want to delete this stock adjustment? This will reverse its impact on stock and ledgers.`, () => {
        const d = getYearData(); // Get fresh year data
        if (!d) return;

        const adjustmentIndex = d.stockAdjustments.findIndex(adj => adj.id === id);
        if (adjustmentIndex === -1) {
            console.error("Stock adjustment not found for deletion.");
            notifyError("Stock adjustment not found for deletion.");
            return;
        }

        // Remove the adjustment log entry
        d.stockAdjustments.splice(adjustmentIndex, 1);

        // Remove the associated journal voucher
        const relatedVoucherIndex = d.vouchers.findIndex(v => v.relatedAdjustmentId === id);
        if (relatedVoucherIndex > -1) {
            d.vouchers.splice(relatedVoucherIndex, 1);
        }

        save();
        // Re-render everything that depends on recalculated stock data
        renderStockItems();
        populateVoucherStockItemDropdown();
        populateAdjustmentItemDropdown();
        renderStockAdjustmentLog();
        showReports();
        renderVouchers(); // Vouchers list might have changed due to deleted journal entry
        notifySuccess("Stock adjustment deleted.");
        resetAdjustmentForm();
    });
}


function renderStockAdjustmentLog() {
    const ul = document.getElementById('stockAdjustmentLogList');
    const d = getYearData();
    ul.innerHTML = '';
    if (!d || !d.stockAdjustments) return;

    // Sort by date, newest first
    d.stockAdjustments.sort((a, b) => new Date(b.date) - new Date(a.date)).forEach(adj => {
        const li = document.createElement('li');
        // newQty is now recalculated by getYearData()
        const itemState = d.stockItems.find(item => item.name === adj.itemName);
        const currentQtyDisplay = itemState ? itemState.currentQty : 'N/A'; // Display N/A if item not found
        let text = `${adj.date}: ${adj.itemName} adjusted by ${adj.adjustedBy} (${adj.reason}). Current Qty: ${currentQtyDisplay}`;
        li.textContent = text;

        const btnDiv = document.createElement('div');
        btnDiv.classList.add('action-buttons');

        const editBtn = document.createElement('span');
        editBtn.textContent = '🪶';
        editBtn.className = 'edit-btn';
        editBtn.onclick = (e) => { e.stopPropagation(); editStockAdjustment(adj.id); };
        btnDiv.appendChild(editBtn);

        const delBtn = document.createElement('span');
        delBtn.textContent = '⛔';
        delBtn.className = 'delete-btn';
        delBtn.onclick = (e) => { e.stopPropagation(); deleteStockAdjustment(adj.id); };
        btnDiv.appendChild(delBtn); 
        
        li.appendChild(btnDiv);
        ul.appendChild(li);
    });
}


function populateVoucherStockItemDropdown() {
  const d = getYearData();
  const select = document.getElementById('voucherStockItem');
  select.innerHTML = '<option value="">Select Stock Item...</option>';
  if (!d || !d.stockItems) return;
  d.stockItems.sort((a,b) => a.name.localeCompare(b.name)).forEach(item => {
    const currentQty = item.currentQty; // Use the recalculated currentQty
    const opt = document.createElement('option');
    opt.value = item.name;
    opt.textContent = `${item.name} (Avail: ${currentQty} ${item.unit})`;
    select.appendChild(opt);
  });
}


// --- Reports & Daybook ---
function renderDaybook() {
    const d = getYearData();
    const tableBody = document.getElementById('daybookTable');
    tableBody.innerHTML = '';
    if (!d || !d.vouchers) return;

    // Sort vouchers by date (oldest first for daybook)
    const sortedVouchers = [...d.vouchers].sort((a, b) => new Date(a.date) - new Date(b.date));

    sortedVouchers.forEach(v => {
        const row = tableBody.insertRow();
        row.insertCell().textContent = v.date;
        row.insertCell().textContent = v.type;
        row.insertCell().textContent = v.debit;
        row.insertCell().textContent = v.credit;
        row.insertCell().textContent = `₹${v.amount.toFixed(2)}`;
        row.insertCell().textContent = v.narration;
    });
}

function showReports() {
  const d = getYearData(); // Get fresh year data
  if (!d) return notifyError("Select company & year to view reports.");

  // Debugging logs
  console.log("--- Debugging showReports ---");
  console.log("Current Year Data (d):", JSON.parse(JSON.stringify(d)));
  console.log("Vouchers for current year:", JSON.parse(JSON.stringify(d.vouchers)));


  // Trial Balance
  let tb = {};

  // Initialize ledger balances with opening balances
  d.ledgers.forEach(l => {
    tb[l.name] = { debit: 0, credit: 0 };
    if (l.openingBalance && l.openingBalance !== 0) {
        // Determine if opening balance is debit or credit based on group type
        const group = l.group;
        const isAssetOrExpense = ['Fixed Assets', 'Investments', 'Current Assets', 'Direct Expenses', 'Indirect Expenses', 'Cash-in-Hand', 'Bank Accounts', 'Sundry Debtors', 'Cost of Goods Sold', 'Stock Adjustment Account'].includes(group); // Exclude Stock-in-Hand here
        const isLiabilityOrIncome = ['Capital Account', 'Loans (Liability)', 'Current Liabilities', 'Sales Accounts', 'Direct Incomes', 'Indirect Incomes', 'Sundry Creditors', 'Duties & Taxes', 'Provisions', 'Reserves & Surplus', 'Secured Loans', 'Unsecured Loans', 'Bank OD A/c'].includes(group);

        if (l.name === 'Stock-in-Hand') {
            // Stock-in-Hand's opening balance will be set later based on currentTotalStockValue
            // For now, initialize it to 0 in TB to avoid double counting or confusion.
            // Its opening balance from stock items is already handled by selectYear.
            // The TB will reflect the *closing* value.
             tb[l.name].debit = 0;
             tb[l.name].credit = 0;
        } else if (isAssetOrExpense) {
            tb[l.name].debit += l.openingBalance;
        } else if (isLiabilityOrIncome) {
            tb[l.name].credit += l.openingBalance;
        } else {
            if (l.openingBalance > 0) {
                tb[l.name].debit += l.openingBalance;
            } else {
                tb[l.name].credit += Math.abs(l.openingBalance);
            }
        }
    }
  });


  console.log("Initial TB object after opening balances:", JSON.parse(JSON.stringify(tb)));


  // Process vouchers
  d.vouchers.forEach(v => {
    // Only update ledgers other than Stock-in-Hand from vouchers
    // Stock-in-Hand's balance in TB will be derived from inventory valuation
    if (v.debit !== 'Stock-in-Hand') {
        if(tb[v.debit]) tb[v.debit].debit += v.amount;
        else {
            const associatedLedger = d.ledgers.find(l => l.name === v.debit);
            if (associatedLedger) tb[v.debit] = {debit: v.amount, credit: 0, group: associatedLedger.group};
            else tb[v.debit] = {debit: v.amount, credit: 0, group: 'Unknown'};
        }
    }

    if (v.credit !== 'Stock-in-Hand') {
        if(tb[v.credit]) tb[v.credit].credit += v.amount;
        else {
            const associatedLedger = d.ledgers.find(l => l.name === v.credit);
            if (associatedLedger) tb[v.credit] = {debit: 0, credit: v.amount, group: associatedLedger.group};
            else tb[v.credit] = {debit: 0, credit: v.amount, group: 'Unknown'};
        }
    }
  });

  console.log("TB object after processing vouchers:", JSON.parse(JSON.stringify(tb)));
  console.log("Trial Balance for 'Cost of Goods Sold' (after vouchers):", tb['Cost of Goods Sold']);


  // Calculate closing stock value from stock master for Inventory Report display
  let currentTotalStockValue = 0;
  if (d.stockItems) {
    d.stockItems.forEach(item => {
      const currentQty = item.currentQty; // Use the recalculated currentQty
      const averageCost = item.averageCost; // Use the recalculated averageCost
      const val = currentQty * averageCost;
      currentTotalStockValue += val;
    });
  }

  // Explicitly set the Stock-in-Hand balance in the Trial Balance to match the Inventory Valuation
  // This is the crucial step to synchronize the two reports.
  if (!tb['Stock-in-Hand']) {
      tb['Stock-in-Hand'] = { debit: 0, credit: 0 };
  }
  tb['Stock-in-Hand'].debit = currentTotalStockValue;
  tb['Stock-in-Hand'].credit = 0;


  let tbHtml = '<h4>Trial Balance</h4><table><tr><th>Ledger</th><th>Debit (₹)</th><th>Credit (₹)</th></tr>';
  let totalDebit = 0, totalCredit = 0;
  for (let lName in tb) {
    const ledgerTotals = tb[lName];
    let netDebit = 0, netCredit = 0;
    const balance = ledgerTotals.debit - ledgerTotals.credit;
    if (balance > 0) {
      netDebit = balance;
      totalDebit += balance;
    } else {
      netCredit = -balance;
      totalCredit += -balance;
    }
    tbHtml += `<tr><td>${lName}</td><td>${netDebit > 0 ? netDebit.toFixed(2) : ''}</td><td>${netCredit > 0 ? netCredit.toFixed(2) : ''}</td></tr>`;
  }
  tbHtml += `<tr><td><b>Total</b></td><td><b>${totalDebit.toFixed(2)}</b></td><td><b>${totalCredit.toFixed(2)}</b></td></tr>`;
  if (Math.abs(totalDebit - totalCredit) > 0.001) { // Check for imbalance
    tbHtml += `<tr><td colspan="3" style="color:red; text-align:center;"><b>Trial Balance does not match! Difference: ₹${Math.abs(totalDebit - totalCredit).toFixed(2)}</b></td></tr>`;
  }
  tbHtml += '</table>';
  document.getElementById('trialBalance').innerHTML = tbHtml;

  // P&L and Balance Sheet
  const incomeGroups = ['Sales Accounts', 'Direct Incomes', 'Indirect Incomes'];
  const expenseGroups = ['Purchase Accounts', 'Direct Expenses', 'Indirect Expenses', 'Cost of Goods Sold', 'Stock Adjustment Account']; // Added COGS and Stock Adjustment Account to expenses
  const assetGroups = ['Fixed Assets', 'Investments', 'Current Assets', 'Cash-in-Hand', 'Bank Accounts', 'Sundry Debtors', 'Stock-in-Hand']; // Stock-in-Hand is now an asset ledger
  const liabilityGroups = ['Capital Account', 'Loans (Liability)', 'Current Liabilities', 'Sundry Creditors', 'Duties & Taxes', 'Provisions', 'Reserves & Surplus', 'Secured Loans', 'Unsecured Loans', 'Bank OD A/c'];

  let income = 0;
  let expense = 0;
  let assets = 0;
  let liabilities = 0;

  // Before P&L calculation loop:
  console.log("Income Groups:", incomeGroups);
  console.log("Expense Groups:", expenseGroups);
  console.log("Ledgers and their groups (from d.ledgers):", d.ledgers.map(l => ({name: l.name, group: l.group})));


  // Calculate P&L and Balance Sheet from Trial Balance balances
  for (let lName in tb) {
    const ledger = d.ledgers.find(l => l.name === lName);
    const group = ledger ? ledger.group : 'Unknown'; // Get group from original ledger or set as unknown

    const balance = tb[lName].debit - tb[lName].credit;

    console.log(`Processing ledger: ${lName}, Group: ${group}, Balance: ${balance.toFixed(2)}`);

    if (incomeGroups.includes(group)) {
      income += -balance; // Income groups typically have credit balances, so negative balance is income
      console.log(`  -> Added to Income. Current Income: ${income.toFixed(2)}`);
    } else if (expenseGroups.includes(group)) {
      expense += balance; // Expense groups typically have debit balances
      console.log(`  -> Added to Expense. Current Expense: ${expense.toFixed(2)}`);
    } else if (assetGroups.includes(group)) { // Stock-in-Hand is now included here
      assets += balance; // Assets have debit balances
    } else if (liabilityGroups.includes(group)) {
      liabilities += -balance; // Liabilities have credit balances, so negative balance is liability
    }
  }

  const profit = income - expense;
  let netProfitStr = `Net ${profit >= 0 ? 'Profit' : 'Loss'}`;

  // After P&L calculation:
  console.log(`Calculated Total Income: ${income.toFixed(2)}`);
  console.log(`Calculated Total Expense: ${expense.toFixed(2)}`);
  console.log(`Calculated Net Profit: ${profit.toFixed(2)}`);
  console.log("--- End Debugging showReports ---");


  document.getElementById('pl').innerHTML = `<h4>Profit & Loss Account</h4>
    <p>Total Income: ₹${income.toFixed(2)}</p>
    <p>Total Expenses: ₹${expense.toFixed(2)}</p>
    <p><b>${netProfitStr}: ₹${Math.abs(profit).toFixed(2)}</b></p`;

  // Adjust liabilities/assets with profit/loss for Balance Sheet
  if (profit >= 0) { // Profit increases capital (liability)
    liabilities += profit;
  } else { // Loss decreases capital (effectively an asset side item or reduction from liability)
    liabilities += profit; // profit is negative here, so it reduces liabilities
  }


  document.getElementById('balanceSheet').innerHTML = `<h4>Balance Sheet</h4>
    <p>Total Assets: ₹${assets.toFixed(2)}</p>
    <p>Total Liabilities (incl. ${netProfitStr} ₹${Math.abs(profit).toFixed(2)}): ₹${liabilities.toFixed(2)}</p>` +
    (Math.abs(assets - liabilities) > 0.01 ? `<p style="color:red;"><b>Balance Sheet does not tally! Difference: ₹${Math.abs(assets - liabilities).toFixed(2)}</b></p>` : `<p style="color:green;"><b>Balance Sheet Tally!</b></p>`);

  // Inventory report
  // Corrected header to explicitly say "Average Cost"
  let invHtml = '<h4>Inventory Valuation Report</h4><table><tr><th>Item</th><th>Current Qty</th><th>Unit</th><th>Average Cost (₹)</th><th>Total Value (₹)</th></tr>'; 
  let totalInvVal = 0;
  if (d.stockItems) {
    d.stockItems.forEach(item => {
      const currentQty = item.currentQty; // Use the recalculated currentQty
      const averageCost = item.averageCost; // Use the recalculated averageCost
      const val = currentQty * averageCost;
      totalInvVal += val;
      invHtml += `<tr><td>${item.name}</td><td>${currentQty}</td><td>${item.unit}</td><td>${averageCost.toFixed(2)}</td><td>${val.toFixed(2)}</td></tr>`;
    });
  }
  invHtml += `<tr><td colspan="4"><b>Total Inventory Value</b></td><td><b>${totalInvVal.toFixed(2)}</b></td></tr>`;
  invHtml += '</table>';
  document.getElementById('inventoryReport').innerHTML = invHtml;
}


// --- Utility Functions ---
function notifySuccess(msg) {
    const note = document.createElement('div');
    note.textContent = msg;
    Object.assign(note.style, {
        position: 'fixed',
        top: '70px',
        left: '50%',
        transform: 'translateX(-50%)',
        background: '#4CAF50', /* Green background */
        color: '#fff',
        padding: '10px 16px',
        borderRadius: '6px',
        boxShadow: '0 2px 8px rgba(0,0,0,0.2)',
        zIndex: '9999',
        fontWeight: '600',
        fontSize: '15px',
        fontFamily: 'Segoe UI, sans-serif',
        maxWidth: '90vw',
        textAlign: 'center',
        wordWrap: 'break-word',
        opacity: '0',
        transition: 'opacity 0.4s ease, transform 0.4s ease',
    });
    document.body.appendChild(note);

    requestAnimationFrame(() => {
        note.style.opacity = '1';
        note.style.transform = 'translateX(-50%) translateY(0)';
    });

    setTimeout(() => {
        note.style.opacity = '0';
        note.style.transform = 'translateX(-50%) translateY(-20px)';
        note.addEventListener('transitionend', () => note.remove());
    }, 3000);
}

function notifyError(msg) {
    const note = document.createElement('div');
    note.textContent = msg;
    Object.assign(note.style, {
        position: 'fixed',
        top: '70px',
        left: '50%',
        transform: 'translateX(-50%)',
        background: '#dc3545', /* Red background */
        color: '#fff',
        padding: '10px 16px',
        borderRadius: '6px',
        boxShadow: '0 2px 8px rgba(0,0,0,0.2)',
        zIndex: '9999',
        fontWeight: '600',
        fontSize: '15px',
        fontFamily: 'Segoe UI, sans-serif',
        maxWidth: '90vw',
        textAlign: 'center',
        wordWrap: 'break-word',
        opacity: '0',
        transition: 'opacity 0.4s ease, transform 0.4s ease',
    });
    document.body.appendChild(note);

    requestAnimationFrame(() => {
        note.style.opacity = '1';
        note.style.transform = 'translateX(-50%) translateY(0)';
    });

    setTimeout(() => {
        note.style.opacity = '0';
        note.style.transform = 'translateX(-50%) translateY(-20px)';
        note.addEventListener('transitionend', () => note.remove());
    }, 4000); // Keep error messages slightly longer
}


// Universal Confirmation Dialog
function showConfirmation(message, onConfirmCallback) {
    // Remove any existing dialogs to prevent duplicates
    const existingOverlay = document.querySelector('.confirmation-overlay');
    if (existingOverlay) {
        existingOverlay.remove();
    }

    const overlay = document.createElement('div');
    overlay.className = 'confirmation-overlay';

    const dialog = document.createElement('div');
    dialog.className = 'confirmation-dialog';

    const p = document.createElement('p');
    p.textContent = message;
    dialog.appendChild(p);

    const buttonContainer = document.createElement('div');
    buttonContainer.className = 'buttons';

    const yesButton = document.createElement('button');
    yesButton.textContent = 'Yes';
    yesButton.className = 'confirm-yes';
    yesButton.onclick = () => {
        onConfirmCallback();
        document.body.removeChild(overlay);
    };

    const noButton = document.createElement('button');
    noButton.textContent = 'No';
    noButton.className = 'confirm-no';
    noButton.onclick = () => {
        document.body.removeChild(overlay);
    };

    buttonContainer.appendChild(yesButton);
    buttonContainer.appendChild(noButton);
    dialog.appendChild(buttonContainer);
    overlay.appendChild(dialog);
    document.body.appendChild(overlay);

    // Animate in
    requestAnimationFrame(() => {
        overlay.style.opacity = '1';
        dialog.style.transform = 'translateY(0)';
    });
}

// Custom Input Confirmation Dialog (for edit function)
function showInputConfirmation(title, message, defaultValue, onConfirmCallback) {
    const existingOverlay = document.querySelector('.confirmation-overlay');
    if (existingOverlay) {
        existingOverlay.remove();
    }

    const overlay = document.createElement('div');
    overlay.className = 'confirmation-overlay';

    const dialog = document.createElement('div');
    dialog.className = 'confirmation-dialog';

    const h4 = document.createElement('h4');
    h4.textContent = title;
    dialog.appendChild(h4);

    const p = document.createElement('p');
    p.textContent = message;
    dialog.appendChild(p);

    const input = document.createElement('input');
    input.type = 'text';
    input.value = defaultValue;
    input.placeholder = 'Enter new name';
    dialog.appendChild(input);

    const buttonContainer = document.createElement('div');
    buttonContainer.className = 'buttons';

    const okButton = document.createElement('button');
    okButton.textContent = 'Save';
    okButton.className = 'confirm-yes'; /* Reusing style for positive action */
    okButton.onclick = () => {
        onConfirmCallback(input.value);
        document.body.removeChild(overlay);
    };

    const cancelButton = document.createElement('button');
    cancelButton.textContent = 'Cancel';
    cancelButton.className = 'confirm-no';
    cancelButton.onclick = () => {
        document.body.removeChild(overlay);
    };

    buttonContainer.appendChild(okButton);
    buttonContainer.appendChild(cancelButton);
    dialog.appendChild(buttonContainer);
    overlay.appendChild(dialog);
    document.body.appendChild(overlay);

    // Focus on input
    input.focus();

    // Animate in
    requestAnimationFrame(() => {
        overlay.style.opacity = '1';
        dialog.style.transform = 'translateY(0)';
    });
}


// Function to refresh the app code, bypassing browser cache
function refreshApp() {
    // This will force the browser to reload all resources from the server,
    // effectively updating the app's code. localStorage data remains untouched.
    window.location.reload(true); 
}

function clearAllData() {
    showConfirmation("Are you absolutely sure you want to clear ALL company data? This action cannot be undone.", () => {
        localStorage.removeItem('swiftData');
        data = { companies: {} };
        currentCompany = '';
        currentYear = '';
        save();
        updateHeader();
        showScreen('companyScreen');
        notifySuccess("All data cleared. Starting fresh!");
    });
}


// Initial load
load(); 
updateHeader(); 
showScreen('companyScreen'); // Show company screen on initial load
</script>
</body>
</html>
